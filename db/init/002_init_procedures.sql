-- Auto-generated procedures file
-- Generated by db/generate_procedures.sh
-- DO NOT EDIT MANUALLY - This file is generated from db/procedures/**/*.sql files

-- ============================================================
-- create procedures
-- ============================================================

-- Source: create/create_credentials.sql

DELIMITER $$

/**
 * Registers login credentials for a faculty member.
 * 
 * Creates a new credentials record for a faculty member, allowing them to
 * log into the system. The password is hashed using a salt for security.
 * Each faculty member can only have one set of credentials, and each
 * username must be unique across all users.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_username    Required username (must be unique, max 255 characters)
 * @param p_password    Required plain text password (will be hashed and salted)
 * 
 * @returns No result set. Use validate_login to test the credentials.
 * 
 * @throws SQLSTATE '45000' if username already exists
 * @throws SQLSTATE '45000' if credentials already exist for this faculty_id
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 */
DROP PROCEDURE IF EXISTS register_credentials$$
CREATE PROCEDURE register_credentials(
    IN p_faculty_id CHAR(36),
    IN p_username VARCHAR(255),
    IN p_password VARCHAR(255)
)

BEGIN
    -- SALT & HASH FOR PW
    DECLARE p_salt VARCHAR(255);
    DECLARE p_hash CHAR(64);

    -- ENFORCE UNIQUE USERNAME
    IF EXISTS (SELECT 1 FROM credentials WHERE username = p_username) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Username already exists';
    END IF;

    -- FORCE ONE SET OF CREDENTIALS PER FACULTY
    IF EXISTS (SELECT 1 FROM credentials WHERE faculty_id = p_faculty_id) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Credentials already registered for this faculty';
    END IF;

    -- GENERATE SALT & HASH
    SET p_salt = UUID();
    SET p_hash = hash_password(p_password, p_salt);

    INSERT INTO credentials (faculty_id, username, password_hash, password_salt, last_login)
    VALUES (p_faculty_id, p_username, p_hash, p_salt, NULL);
END $$

DELIMITER ;


-- Source: create/create_equipment.sql

DELIMITER $$

/**
 * Creates a new equipment record in the database.
 * 
 * Inserts a new equipment record with the provided information. All parameters
 * are required except description, which is optional. The equipment must be
 * associated with an existing institution.
 * 
 * @param p_equipment_id    Required UUID for the equipment record
 * @param p_name            Required equipment name (max 64 characters)
 * @param p_description     Optional description of the equipment (max 2048 characters)
 * @param p_availability    Required availability information (max 2048 characters)
 *                          Describes when and how the equipment is available
 * @param p_institution_id  Required UUID of the institution that owns the equipment
 *                          Must reference an existing institution record
 * 
 * @throws SQLSTATE '23000' if institution_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if equipment_id already exists (primary key constraint)
 */
DROP PROCEDURE IF EXISTS create_equipment$$
CREATE PROCEDURE create_equipment(
    IN p_equipment_id CHAR(36),
    IN p_name VARCHAR(64),
    IN p_description VARCHAR(2048),
    IN p_availability VARCHAR(2048),
    IN p_institution_id CHAR(36)    
)
BEGIN
    INSERT INTO equipment (
        equipment_id, 
        name, 
        description,
        availability, 
        institution_id
    ) VALUES (
        p_equipment_id, 
        p_name, 
        p_description, 
        p_availability, 
        p_institution_id)
    ;
END $$

DELIMITER ;

-- Source: create/create_faculty.sql

DELIMITER $$

/**
 * Creates a new faculty member record in the database.
 * 
 * Inserts a new faculty record with the provided information.
 * Only first_name & faculty_id are required; all other fields are optional.
 * 
 * @param p_faculty_id          Required UUID for the faculty member
 * @param p_first_name          Required first name of the faculty member
 * @param p_last_name           Optional last name
 * @param p_biography           Optional biography text (max 2048 chars)
 * @param p_orcid               Optional ORCID identifier (19 characters)
 * @param p_google_scholar_url  Optional Google Scholar profile URL
 * @param p_research_gate_url   Optional ResearchGate profile URL
 * @param p_scraped_from        Optional source URL if data was scraped
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the newly created faculty member
 * 
 * @throws SQLSTATE '45000' if first_name is NULL
 */
DROP PROCEDURE IF EXISTS create_faculty$$
CREATE PROCEDURE create_faculty (
    IN p_faculty_id          CHAR(36),
    IN p_first_name          VARCHAR(128),
    IN p_last_name           VARCHAR(128),
    IN p_biography           VARCHAR(2048),
    IN p_orcid               CHAR(19),
    IN p_google_scholar_url  VARCHAR(255),
    IN p_research_gate_url   VARCHAR(255),
    IN p_scraped_from        VARCHAR(255)
)
BEGIN

    -- Validate that faculty_id is provided (required field)
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required when creating a faculty record';
    END IF;

    -- Validate that first_name is provided (required field)
    IF p_first_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'first_name is required when creating a faculty record';
    END IF;

    -- Insert the new faculty record with all provided information
    -- NULL values are allowed for optional fields (last_name, biography, etc.)
    INSERT INTO faculty (
        faculty_id,
        first_name,
        last_name,
        biography,
        orcid,
        google_scholar_url,
        research_gate_url,
        scraped_from
    )
    VALUES (
        p_faculty_id,
        p_first_name,
        p_last_name,
        p_biography,
        p_orcid,
        p_google_scholar_url,
        p_research_gate_url,
        p_scraped_from
    );

    -- Return the faculty_id so the caller knows the new faculty member's identifier
    SELECT p_faculty_id AS faculty_id;
END $$

DELIMITER ;


-- Source: create/create_faculty_department.sql

DELIMITER $$

/**
 * Associates a department with a faculty member.
 * 
 * Inserts a new department association for the specified faculty member.
 * Faculty members can belong to multiple departments, so this creates an
 * additional department association rather than replacing existing ones.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_department_name Required name of the department
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - department_name: The department name that was inserted
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if faculty_id or department_name is NULL
 */
CREATE PROCEDURE create_faculty_department (
    IN p_faculty_id CHAR(36),
    IN p_department_name VARCHAR(128)
)
BEGIN
    -- Validate that both required parameters are provided
    IF p_faculty_id IS NULL OR p_department_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and department_name are required.';
    END IF;

    -- Insert a new department association for the faculty member
    -- Faculty can belong to multiple departments (e.g., joint appointments)
    -- The combination of faculty_id and department_name should be unique
    INSERT INTO faculty_department (faculty_id, department_name)
    VALUES (p_faculty_id, p_department_name);

    -- Return confirmation with the inserted values
    SELECT p_faculty_id AS faculty_id,
           p_department_name AS department_name,
           'inserted' AS action;
END $$

DELIMITER ;

-- Source: create/create_faculty_email.sql

DELIMITER $$

/**
 * Adds an email address to a faculty member.
 * 
 * Inserts a new email record for the specified faculty member. Faculty
 * members can have multiple email addresses, so this creates an additional
 * email association rather than replacing existing ones.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_email       Required email address to associate with the faculty member
 * 
 * @returns No result set (unlike other create procedures)
 */
CREATE PROCEDURE create_faculty_email (
    IN p_faculty_id CHAR(36),
    IN p_email      VARCHAR(255)
)
BEGIN
    -- Insert a new email address for the faculty member
    -- Faculty can have multiple email addresses (e.g., work, personal, lab)
    -- The combination of faculty_id and email should be unique
    -- Note: This procedure does not return a result set (unlike other create procedures)
    INSERT INTO faculty_email (faculty_id, email)
    VALUES (p_faculty_id, p_email);
END$$

DELIMITER ;

-- Source: create/create_faculty_follows_faculty.sql

DELIMITER $$

/**
 * Creates a follow relationship between two faculty members.
 * 
 * Inserts a new follow relationship where one faculty member (follower)
 * follows another faculty member (followee). A faculty member cannot
 * follow themselves.
 * 
 * @param p_follower_id  Required UUID of the faculty member who is following
 * @param p_followee_id  Required UUID of the faculty member being followed
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if follower_id or followee_id is NULL, if they are the same, or if either faculty doesn't exist
 */
CREATE PROCEDURE create_faculty_follows_faculty (
    IN p_follower_id CHAR(36),
    IN p_followee_id CHAR(36)
)
BEGIN
    DECLARE follower_exists INT;
    DECLARE followee_exists INT;

    -- Validate that both required parameters are provided
    IF p_follower_id IS NULL OR p_followee_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'follower_id and followee_id are required.';
    END IF;

    -- Prevent a faculty member from following themselves
    IF p_follower_id = p_followee_id THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'A faculty member cannot follow themselves.';
    END IF;

    -- Verify that the follower exists
    SELECT COUNT(*) INTO follower_exists
    FROM faculty
    WHERE faculty_id = p_follower_id;

    IF follower_exists = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'follower_id does not exist.';
    END IF;

    -- Verify that the followee exists
    SELECT COUNT(*) INTO followee_exists
    FROM faculty
    WHERE faculty_id = p_followee_id;

    IF followee_exists = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'followee_id does not exist.';
    END IF;

    -- Insert the follow relationship
    -- The composite primary key ensures uniqueness (a faculty can only follow another faculty once)
    INSERT INTO faculty_follows_faculty (follower_id, followee_id)
    VALUES (p_follower_id, p_followee_id);

    -- Return confirmation with the inserted values
    SELECT p_follower_id AS follower_id,
           p_followee_id AS followee_id,
           'inserted' AS action;
END $$

DELIMITER ;


-- Source: create/create_faculty_generates_keyword.sql

DELIMITER $$

/**
 * Creates a new faculty keyword generation record.
 * 
 * Inserts a record tracking when a faculty member requested keyword generation
 * using an LLM. This is used to enforce rate limiting on LLM usage.
 * 
 * @param p_generation_id  Required UUID for the generation record
 * @param p_faculty_id     Required UUID of the faculty member making the request
 *                         Must reference an existing faculty record
 * @param p_generated_at   Optional timestamp of when the request was made
 *                         If NULL, uses current timestamp
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
* @throws SQLSTATE '45000' if generation_id or faculty_id is NULL
 */
CREATE PROCEDURE create_faculty_generates_keyword(
    IN p_generation_id CHAR(36),
    IN p_faculty_id CHAR(36),
    IN p_generated_at DATETIME
)
BEGIN
    -- Validate required parameters
    IF p_generation_id IS NULL OR TRIM(p_generation_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'generation_id is required for create_faculty_generates_keyword';
    END IF;

    IF p_faculty_id IS NULL OR TRIM(p_faculty_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required for create_faculty_generates_keyword';
    END IF;

    -- Insert record, using current timestamp if p_generated_at is NULL
    INSERT INTO faculty_generates_keyword (generation_id, faculty_id, generated_at)
    VALUES (p_generation_id, p_faculty_id, COALESCE(p_generated_at, NOW()));
END $$

DELIMITER ;



-- Source: create/create_faculty_phone.sql

DELIMITER $$

/**
 * Adds a phone number to a faculty member.
 * 
 * Inserts a new phone number record for the specified faculty member.
 * Faculty members can have multiple phone numbers, so this creates an
 * additional phone number association rather than replacing existing ones.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_phone_num   Required phone number to associate with the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - phone_num: The phone number that was inserted
 *   - action: Status message ('inserted')
 */
CREATE PROCEDURE create_faculty_phone (
    IN p_faculty_id CHAR(36),
    IN p_phone_num  VARCHAR(32)
)
BEGIN
    -- Insert a new phone number for the faculty member
    -- Faculty can have multiple phone numbers (e.g., office, mobile, lab)
    -- The combination of faculty_id and phone_num should be unique
    INSERT INTO faculty_phone (faculty_id, phone_num)
    VALUES (p_faculty_id, p_phone_num);

    -- Return confirmation with the inserted values
    SELECT p_faculty_id AS faculty_id,
           p_phone_num AS phone_num,
           'inserted' AS action;
END$$

DELIMITER ;

-- Source: create/create_faculty_researches_keyword.sql

DELIMITER $$

/**
 * Associates a keyword with a faculty member's research interests.
 * 
 * Inserts a record into the faculty_researches_keyword join table, establishing
 * that a specific faculty member researches a specific keyword. This allows
 * faculty members to have multiple research interests and enables searching
 * faculty by their research areas.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 *                      Must reference an existing faculty record
 * @param p_name        Required keyword name (max 64 characters)
 *                      Must reference an existing keyword record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if keyword name doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the faculty-keyword association already exists (unique constraint)
 */
CREATE PROCEDURE create_faculty_researches_keyword(
    IN p_faculty_id CHAR(36),
    IN p_name VARCHAR(64)
)
BEGIN
    INSERT INTO faculty_researches_keyword (name, faculty_id)
    VALUES (p_name, p_faculty_id);
END $$

DELIMITER ;


-- Source: create/create_faculty_title.sql

DELIMITER $$

/**
 * Adds a title to a faculty member.
 * 
 * Inserts a new title record for the specified faculty member. Faculty members
 * can have multiple titles, so this creates an additional title association
 * rather than replacing existing ones.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_title       Required title to associate with the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - title: The title that was inserted
 *   - action: Status message ('inserted')
 */
CREATE PROCEDURE create_faculty_title (
    IN p_faculty_id CHAR(36),
    IN p_title      VARCHAR(255)
)
BEGIN
    -- Insert a new title association for the faculty member
    -- This allows faculty to have multiple titles (e.g., "Professor", "Department Chair")
    -- The combination of faculty_id and title should be unique
    INSERT INTO faculty_title (faculty_id, title)
    VALUES (p_faculty_id, p_title);

    -- Return confirmation with the inserted values
    SELECT p_faculty_id AS faculty_id,
           p_title AS title,
           'inserted' AS action;
END$$

DELIMITER ;

-- Source: create/create_faculty_works_at_institution.sql

DELIMITER $$

/**
 * Creates a new faculty-institution relationship record in the database.
 * 
 * Inserts a new faculty_works_at_institution record establishing a relationship
 * between a faculty member and an institution. This represents an employment
 * period, with a start date (required) and optional end date. The composite
 * primary key (faculty_id, institution_id, start_date) must be unique.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 *                          Must reference an existing faculty record
 * @param p_institution_id  Required UUID of the institution
 *                          Must reference an existing institution record
 * @param p_start_date      Required start date of the employment relationship
 *                          Part of the composite primary key
 * @param p_end_date        Optional end date of the employment relationship
 *                          NULL indicates the faculty member currently works at the institution
 * 
 * @returns No result set. Use read_faculty_works_at_institution to verify the insert.
 * 
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if institution_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if a record with the same (faculty_id, institution_id, start_date) already exists
 */
DROP PROCEDURE IF EXISTS create_faculty_works_at_institution$$
CREATE PROCEDURE create_faculty_works_at_institution(
    IN p_faculty_id CHAR(36),
    IN p_institution_id CHAR(36),
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    INSERT INTO faculty_works_at_institution(
        faculty_id, 
        institution_id, 
        start_date, 
        end_date
    ) VALUES (
        p_faculty_id, 
        p_institution_id, 
        p_start_date, 
        p_end_date
    );
END $$

DELIMITER ;

-- Source: create/create_grants.sql

DELIMITER $$

/**
 * Creates a new grant record in the database.
 * 
 * Inserts a new grant record with the provided information. Grants represent
 * funding awards with a specific amount, description, and time period.
 * 
 * @param p_grant_id      Required UUID for the grant record
 * @param p_description   Optional description of the grant (TEXT field)
 * @param p_amount        Required grant amount (DECIMAL with 10 digits, 2 decimal places)
 * @param p_start_date    Required start date of the grant period
 * @param p_end_date      Optional end date of the grant period (NULL if ongoing)
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if grant_id already exists (primary key constraint)
 */
DROP PROCEDURE IF EXISTS create_grants$$
CREATE PROCEDURE create_grants(
    IN      p_grant_id      CHAR(36),
    IN      p_description   TEXT,
    IN      p_amount        DECIMAL(10,2),
    IN      p_start_date    DATE,
    IN      p_end_date      DATE
)

BEGIN
    INSERT INTO grants(
        grant_id, description, amount, start_date, end_date
    ) VALUES (
        p_grant_id, p_description, p_amount, p_start_date, p_end_date
    );
END $$

DELIMITER ;


-- Source: create/create_grants_for_keyword.sql

DELIMITER $$

/**
 * Associates a grant with a keyword.
 * 
 * Inserts a record into the grants_for_keyword join table, establishing
 * that a specific grant is related to a specific keyword. This allows
 * grants to be categorized and searched by research keywords.
 * 
 * @param p_grant_id  Required UUID of the grant
 *                    Must reference an existing grant record
 * @param p_name      Required keyword name (max 64 characters)
 *                    Must reference an existing keyword record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if grant_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if keyword name doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the grant-keyword association already exists (unique constraint)
 */
DROP PROCEDURE IF EXISTS create_grants_for_keyword$$
CREATE PROCEDURE create_grants_for_keyword(
    IN p_grant_id  CHAR(36),
    IN p_name      VARCHAR(64)
)
BEGIN
    INSERT INTO grants_for_keyword(grant_id, name) 
    VALUES(p_grant_id, p_name);
END $$
DELIMITER ;


-- Source: create/create_grants_granted_to_faculty.sql

DELIMITER $$

/**
 * Associates a grant with a faculty member.
 * 
 * Inserts a record into the grants_granted_to_faculty join table, establishing
 * that a specific faculty member is a recipient of a specific grant. This
 * allows tracking which faculty members have received which grants.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 *                      Must reference an existing faculty record
 * @param p_grant_id    Required UUID of the grant
 *                      Must reference an existing grant record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if grant_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the faculty-grant association already exists (unique constraint)
 */
DROP PROCEDURE IF EXISTS create_grants_granted_to_faculty$$
CREATE PROCEDURE create_grants_granted_to_faculty(
    IN p_faculty_id    CHAR(36),
    IN p_grant_id      CHAR(36)
)
BEGIN
    INSERT INTO grants_granted_to_faculty(faculty_id, grant_id)
    VALUES(p_faculty_id, p_grant_id);
END $$
DELIMITER ;


-- Source: create/create_institution.sql

DELIMITER $$

/**
 * Creates a new institution record in the database.
 * 
 * Inserts a new institution record with the provided information. The institution_id
 * and name are required, along with country. All other location and contact fields
 * are optional. The zip code must be exactly 5 digits if provided.
 * 
 * @param p_institution_id  Required UUID for the institution record
 * @param p_name            Required institution name (max 256 characters)
 * @param p_street_addr     Optional street address (max 255 characters)
 * @param p_city            Optional city name (max 255 characters)
 * @param p_state           Optional state or province (max 255 characters)
 * @param p_country         Required country name (max 255 characters)
 * @param p_zip             Optional postal code (must be exactly 5 digits if provided)
 * @param p_website_url     Optional website URL (max 255 characters)
 * @param p_type            Optional institution type (ENUM: 'Public University', 'Private University', 'Community College')
 * 
 * @returns No result set. Use read_institution to verify the insert.
 * 
 * @throws SQLSTATE '23000' if institution_id already exists (primary key constraint)
 * @throws SQLSTATE 'HY000' if zip code format is invalid (must be 5 digits)
 */
DROP PROCEDURE IF EXISTS create_institution$$
CREATE PROCEDURE create_institution(
    IN p_institution_id CHAR(36),
    IN p_name VARCHAR(256),
    IN p_street_addr VARCHAR(255),
    IN p_city VARCHAR(255),
    IN p_state VARCHAR(255),
    IN p_country VARCHAR(255),
    IN p_zip VARCHAR(16),
    IN p_website_url VARCHAR(255),
    IN p_type VARCHAR(64)
)
BEGIN
    INSERT INTO institution (
        institution_id,
        name,
        street_addr,
        city,
        state,
        country,
        zip,
        website_url,
        type
    ) VALUES (
        p_institution_id,
        p_name,
        p_street_addr,
        p_city,
        p_state,
        p_country,
        p_zip,
        p_website_url,
        p_type
    );
END $$

DELIMITER ;


-- Source: create/create_keyword.sql

DELIMITER $$

/**
 * Creates a new keyword record in the database.
 * 
 * Inserts a new keyword with the provided name. Keywords are used to tag
 * and categorize research areas, publications, and faculty interests.
 * 
 * @param p_name  Required keyword name (max 64 characters)
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if a keyword with the same name already exists (unique constraint)
 */
CREATE PROCEDURE create_keyword(
    IN p_name VARCHAR(64)
)
BEGIN
    INSERT INTO keyword (name)
    VALUES (p_name);
END $$

DELIMITER ;


-- Source: create/create_publication.sql

DELIMITER $$

/**
 * Creates a new publication record in the database.
 * 
 * Inserts a new publication with the provided information. Publications
 * represent scholarly works such as papers, articles, books, etc. The
 * citation_count is automatically initialized to 0.
 * 
 * @param p_id         Required UUID for the publication record
 * @param p_title      Required publication title (max 128 characters)
 * @param p_publisher  Optional publisher name (max 255 characters)
 * @param p_year       Optional publication year (INT)
 * @param p_doi        Optional Digital Object Identifier (max 64 characters)
 * @param p_abstract   Optional abstract text (TEXT field)
 * @param p_citation_count Optional citation count (INT)
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if publication_id already exists (primary key constraint)
 */
CREATE PROCEDURE create_publication(
    IN p_id CHAR(36),
    IN p_title VARCHAR(128),
    IN p_publisher VARCHAR(255),
    IN p_year INT,
    IN p_doi VARCHAR(64),
    IN p_abstract TEXT,
    IN p_citation_count INT
)
BEGIN
    -- Validate input: publication_id must be provided
    IF p_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'publication_id is required.';
    END IF;

    INSERT INTO publication (publication_id, title, publisher, year, doi, abstract, citation_count)
    VALUES (p_id, p_title, p_publisher, p_year, p_doi, p_abstract, p_citation_count);
END $$
DELIMITER ;


-- Source: create/create_publication_authored_by_faculty.sql

DELIMITER $$

/**
 * Creates an association between a faculty member and a publication.
 * 
 * Inserts a record into the publication_authored_by_faculty join table,
 * establishing that a specific faculty member authored a specific publication.
 * This allows many-to-many relationships between faculty and publications.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_publication_id  Required UUID of the publication
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - publication_id: UUID of the publication
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if faculty_id or publication_id is NULL
 */
CREATE PROCEDURE create_publication_authored_by_faculty (
    IN p_faculty_id CHAR(36),
    IN p_publication_id CHAR(36)
)
BEGIN
    -- Validate that both IDs are provided (neither can be NULL)
    IF p_faculty_id IS NULL OR p_publication_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and publication_id are required.';
    END IF;

    -- Insert the relationship into the join table
    -- This creates a link between a faculty member and a publication
    -- Note: If this relationship already exists, this will fail due to unique constraint
    INSERT INTO publication_authored_by_faculty (faculty_id, publication_id)
    VALUES (p_faculty_id, p_publication_id);

    -- Return confirmation with both IDs to verify the relationship was created
    SELECT p_faculty_id AS faculty_id,
           p_publication_id AS publication_id,
           'inserted' AS action;
END $$
DELIMITER ;


-- Source: create/create_publication_explores_keyword.sql

DELIMITER $$

/**
 * Associates a keyword with a publication.
 * 
 * Inserts a record into the publication_explores_keyword join table, establishing
 * that a specific publication explores or is related to a specific keyword.
 * This allows publications to be tagged with multiple keywords for categorization
 * and searching.
 * 
 * @param p_publication_id  Required UUID of the publication
 *                          Must reference an existing publication record
 * @param p_name            Required keyword name (max 64 characters)
 *                          Must reference an existing keyword record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if publication_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if keyword name doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the publication-keyword association already exists (unique constraint)
 */
CREATE PROCEDURE create_publication_explores_keyword(
    IN p_publication_id CHAR(36),
    IN p_name VARCHAR(64)
)
BEGIN
    INSERT INTO publication_explores_keyword(publication_id, name)
    VALUES (p_publication_id, p_name);
END $$

DELIMITER ;


-- Source: create/create_session.sql

DELIMITER $$

/**
 * Creates a new session record in the database.
 * 
 * Inserts a new session with a hashed refresh token for long-term authentication.
 * Sessions are used to maintain user login state across browser sessions.
 * The refresh token is hashed using SHA-256 before storage for security.
 * 
 * @param p_session_id    Required UUID for the session record
 * @param p_faculty_id    Required UUID of the faculty member
 * @param p_token_hash     Required SHA-256 hash of the refresh token (64 characters)
 * @param p_expires_at     Required expiration datetime for the session
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if session_id or token_hash already exists (unique constraint)
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 */
DROP PROCEDURE IF EXISTS create_session$$
CREATE PROCEDURE create_session(
    IN p_session_id CHAR(36),
    IN p_faculty_id CHAR(36),
    IN p_token_hash VARCHAR(64),
    IN p_expires_at DATETIME
)
BEGIN
    -- Validate required fields
    IF p_session_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'session_id is required';
    END IF;

    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required';
    END IF;

    IF p_token_hash IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'token_hash is required';
    END IF;

    IF p_expires_at IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'expires_at is required';
    END IF;

    -- Insert session record
    INSERT INTO session (
        session_id,
        faculty_id,
        token_hash,
        created_at,
        expires_at,
        revoked
    )
    VALUES (
        p_session_id,
        p_faculty_id,
        p_token_hash,
        UTC_TIMESTAMP(),
        p_expires_at,
        FALSE
    );
END $$

DELIMITER ;



-- ============================================================
-- read procedures
-- ============================================================

-- Source: read/read_equipment.sql

DELIMITER $$

/**
 * Retrieves equipment records from the database with optional filtering.
 * 
 * Returns equipment information based on the provided filters. If both
 * parameters are NULL, all equipment records in the database are returned.
 * Results are ordered alphabetically by equipment name.
 * 
 * @param p_equipment_id     Optional UUID of a specific equipment item to retrieve.
 *                          When provided, only that equipment record is returned.
 * @param p_institution_id  Optional UUID of an institution to filter by.
 *                          When provided, only equipment belonging to that institution is returned.
 * 
 * @returns Result set containing all columns from the equipment table:
 *   - equipment_id
 *   - name
 *   - description
 *   - availability
 *   - institution_id
 * 
 * If both parameters are NULL, returns all equipment records ordered by name.
 */
CREATE PROCEDURE read_equipment (
    IN p_equipment_id   CHAR(36),
    IN p_institution_id CHAR(36)
)
BEGIN
    SELECT e.*
    FROM equipment e
    WHERE (p_equipment_id IS NULL OR e.equipment_id = p_equipment_id)
      AND (p_institution_id IS NULL OR e.institution_id = p_institution_id)
    ORDER BY e.name;
END $$

DELIMITER ;


-- Source: read/read_faculty.sql

DELIMITER $$

/**
 * Retrieves a faculty member record by their ID.
 * 
 * Fetches all information for a specific faculty member identified by
 * their unique faculty_id.
 * 
 * @param p_faculty_id  Required UUID of the faculty member to retrieve
 * 
 * @returns Result set containing all columns from the faculty table:
 *   - faculty_id
 *   - first_name
 *   - last_name
 *   - biography
 *   - orcid
 *   - google_scholar_url
 *   - research_gate_url
 *   - scraped_from
 */
CREATE PROCEDURE read_faculty(
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Simple SELECT query to retrieve all columns for the specified faculty member
    -- Uses table alias 'f' for clarity
    -- Returns all fields from the faculty table for the matching ID
    SELECT f.*
    FROM faculty f
    WHERE f.faculty_id = p_faculty_id;
END $$
DELIMITER ;


-- Source: read/read_faculty_department.sql

DELIMITER $$

/**
 * Retrieves all department records from the database.
 * 
 * Returns all records from the faculty_department table.
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - department_name: Department name
 * 
 * Results are ordered by faculty_id, then department_name.
 */
DROP PROCEDURE IF EXISTS read_faculty_department$$
CREATE PROCEDURE read_faculty_department()
BEGIN
    SELECT faculty_id, department_name
    FROM faculty_department
    ORDER BY faculty_id, department_name;
END $$

DELIMITER ;



-- Source: read/read_faculty_department_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all departments associated with a faculty member.
 * 
 * Returns all department records for the specified faculty member. Since
 * faculty members can belong to multiple departments, this may return
 * multiple rows.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - department_name: One department name associated with the faculty member
 *   (Multiple rows if the faculty member belongs to multiple departments)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_department_by_faculty$$
CREATE PROCEDURE read_faculty_department_by_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Validate that faculty_id is provided
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required.';
    END IF;

    -- Retrieve all departments for the specified faculty member
    -- Returns multiple rows if the faculty member belongs to multiple departments
    -- Each row represents one department association
    -- Only returns department_name (not faculty_id) since it's already known
    SELECT department_name
    FROM faculty_department
    WHERE faculty_id = p_faculty_id;
END $$

DELIMITER ;

-- Source: read/read_faculty_email.sql

DELIMITER $$

/**
 * Retrieves all email records from the database.
 * 
 * Returns all records from the faculty_email table.
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - email: Email address
 * 
 * Results are ordered by faculty_id, then email.
 */
DROP PROCEDURE IF EXISTS read_faculty_email$$
CREATE PROCEDURE read_faculty_email()
BEGIN
    SELECT faculty_id, email
    FROM faculty_email
    ORDER BY faculty_id, email;
END $$

DELIMITER ;



-- Source: read/read_faculty_email_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all email addresses associated with a faculty member.
 * 
 * Returns all email records for the specified faculty member. Since
 * faculty members can have multiple email addresses, this may return
 * multiple rows.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - email: One email address associated with the faculty member
 *   (Multiple rows if the faculty member has multiple email addresses)
 */
DROP PROCEDURE IF EXISTS read_faculty_email_by_faculty$$
CREATE PROCEDURE read_faculty_email_by_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Retrieve all email addresses for the specified faculty member
    -- Returns multiple rows if the faculty member has multiple email addresses
    -- Each row represents one email address association
    SELECT faculty_id, email
    FROM faculty_email
    WHERE faculty_id = p_faculty_id;
END$$

DELIMITER ;

-- Source: read/read_faculty_follows_faculty.sql

DELIMITER $$

/**
 * Retrieves all follow relationships from the database.
 * 
 * Returns all records from the faculty_follows_faculty table, showing
 * all follow relationships between faculty members.
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 * 
 * Results are ordered by follower_id, then followee_id.
 */
DROP PROCEDURE IF EXISTS read_faculty_follows_faculty$$
CREATE PROCEDURE read_faculty_follows_faculty()
BEGIN
    SELECT 
        follower_id,
        followee_id
    FROM faculty_follows_faculty
    ORDER BY follower_id, followee_id;
END $$

DELIMITER ;



-- Source: read/read_faculty_follows_faculty_by_followee.sql

DELIMITER $$

/**
 * Retrieves all faculty members who follow a given faculty member.
 * 
 * Returns all follow relationships where the specified faculty member
 * is the followee. This shows who is following the faculty member.
 * 
 * @param p_faculty_id  Required UUID of the faculty member (followee)
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 *   (Multiple rows if multiple people follow the faculty member)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_follows_faculty_by_followee$$
CREATE PROCEDURE read_faculty_follows_faculty_by_followee (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Validate that faculty_id is provided
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required.';
    END IF;

    -- Retrieve all follow relationships where the specified faculty member is the followee
    -- Returns multiple rows if multiple people follow the faculty member
    -- Each row represents one follow relationship
    SELECT follower_id, followee_id
    FROM faculty_follows_faculty
    WHERE followee_id = p_faculty_id;
END $$
DELIMITER ;



-- Source: read/read_faculty_follows_faculty_by_follower.sql

DELIMITER $$

/**
 * Retrieves all faculty members that a given faculty member follows.
 * 
 * Returns all follow relationships where the specified faculty member
 * is the follower. This shows who the faculty member is following.
 * 
 * @param p_faculty_id  Required UUID of the faculty member (follower)
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 *   (Multiple rows if the faculty member follows multiple people)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_follows_faculty_by_follower$$
CREATE PROCEDURE read_faculty_follows_faculty_by_follower (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Validate that faculty_id is provided
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required.';
    END IF;

    -- Retrieve all follow relationships where the specified faculty member is the follower
    -- Returns multiple rows if the faculty member follows multiple people
    -- Each row represents one follow relationship
    SELECT follower_id, followee_id
    FROM faculty_follows_faculty
    WHERE follower_id = p_faculty_id;
END $$

DELIMITER ;


-- Source: read/read_faculty_generates_keyword.sql

DELIMITER $$

/**
 * Retrieves faculty keyword generation records.
 * 
 * Fetches records of when faculty members requested keyword generation.
 * Can filter by faculty_id and optionally by time range for rate limiting checks.
 * 
 * @param p_generation_id  Optional UUID of a specific generation record to retrieve
 *                         If provided, returns only that record
 * @param p_faculty_id     Optional UUID of the faculty member
 *                         If provided, returns all generation records for that faculty
 * @param p_start_date     Optional start date for filtering by time range
 *                         If provided with p_end_date, returns records within range
 * @param p_end_date       Optional end date for filtering by time range
 *                         If provided with p_start_date, returns records within range
 * 
 * @returns Result set containing:
 *   - generation_id: UUID of the generation record
 *   - faculty_id: UUID of the faculty member
 *   - generated_at: Timestamp when the request was made
 * 
 * If both p_generation_id and p_faculty_id are NULL, returns an error.
 * Results are ordered by generated_at descending (most recent first).
 */
CREATE PROCEDURE read_faculty_generates_keyword(
    IN p_generation_id CHAR(36),
    IN p_faculty_id CHAR(36),
    IN p_start_date DATETIME,
    IN p_end_date DATETIME
)
BEGIN

    IF p_generation_id IS NULL AND p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Either generation_id or faculty_id must be provided for read_faculty_generates_keyword';
    END IF;

    SELECT 
        generation_id,
        faculty_id,
        generated_at
    FROM faculty_generates_keyword
    WHERE 
        (p_generation_id IS NULL OR generation_id = p_generation_id)
        AND (p_faculty_id IS NULL OR faculty_id = p_faculty_id)
        AND (p_start_date IS NULL OR generated_at >= p_start_date)
        AND (p_end_date IS NULL OR generated_at <= p_end_date)
    ORDER BY generated_at DESC;
END $$

DELIMITER ;



-- Source: read/read_faculty_phone.sql

DELIMITER $$

/**
 * Retrieves all phone number records from the database.
 * 
 * Returns all records from the faculty_phone table.
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - phone_num: Phone number
 * 
 * Results are ordered by faculty_id, then phone_num.
 */
DROP PROCEDURE IF EXISTS read_faculty_phone$$
CREATE PROCEDURE read_faculty_phone()
BEGIN
    SELECT faculty_id, phone_num
    FROM faculty_phone
    ORDER BY faculty_id, phone_num;
END $$

DELIMITER ;



-- Source: read/read_faculty_phone_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all phone numbers associated with a faculty member.
 * 
 * Returns all phone number records for the specified faculty member.
 * Since faculty members can have multiple phone numbers, this may return
 * multiple rows.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - phone_num: One phone number associated with the faculty member
 *   (Multiple rows if the faculty member has multiple phone numbers)
 */
DROP PROCEDURE IF EXISTS read_faculty_phone_by_faculty$$
CREATE PROCEDURE read_faculty_phone_by_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Retrieve all phone numbers for the specified faculty member
    -- Returns multiple rows if the faculty member has multiple phone numbers
    -- Each row represents one phone number association
    SELECT faculty_id, phone_num
    FROM faculty_phone
    WHERE faculty_id = p_faculty_id;
END$$

DELIMITER ;

-- Source: read/read_faculty_researches_keyword_by_faculty.sql

