-- Auto-generated procedures file
-- Generated by db/generate_procedures.sh
-- DO NOT EDIT MANUALLY - This file is generated from db/procedures/**/*.sql files

-- ============================================================
-- create procedures
-- ============================================================

-- Source: create/create_credentials.sql

DELIMITER $$

/**
 * Registers login credentials for a faculty member.
 * 
 * Creates a new credentials record for a faculty member, allowing them to
 * log into the system. The password is hashed using a salt for security.
 * Each faculty member can only have one set of credentials, and each
 * username must be unique across all users.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_username    Required username (must be unique, max 255 characters)
 * @param p_password    Required plain text password (will be hashed and salted)
 * 
 * @returns No result set. Use validate_login to test the credentials.
 * 
 * @throws SQLSTATE '45000' if username already exists
 * @throws SQLSTATE '45000' if credentials already exist for this faculty_id
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 */
DROP PROCEDURE IF EXISTS register_credentials;
CREATE PROCEDURE register_credentials(
    IN p_faculty_id CHAR(36),
    IN p_username VARCHAR(255),
    IN p_password VARCHAR(255)
)

BEGIN
    -- SALT & HASH FOR PW
    DECLARE p_salt VARCHAR(255);
    DECLARE p_hash CHAR(64);

    -- ENFORCE UNIQUE USERNAME
    IF EXISTS (SELECT 1 FROM credentials WHERE username = p_username) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Username already exists';
    END IF;

    -- FORCE ONE SET OF CREDENTIALS PER FACULTY
    IF EXISTS (SELECT 1 FROM credentials WHERE faculty_id = p_faculty_id) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Credentials already registered for this faculty';
    END IF;

    -- GENERATE SALT & HASH
    SET p_salt = UUID();
    SET p_hash = hash_password(p_password, p_salt);

    INSERT INTO credentials (faculty_id, username, password_hash, password_salt, last_login)
    VALUES (p_faculty_id, p_username, p_hash, p_salt, NULL);
END $$

DELIMITER ;


-- Source: create/create_equipment.sql

DELIMITER $$

/**
 * Creates a new equipment record in the database.
 * 
 * Inserts a new equipment record with the provided information. All parameters
 * are required except description, which is optional. The equipment must be
 * associated with an existing institution.
 * 
 * @param p_equipment_id    Required UUID for the equipment record
 * @param p_name            Required equipment name (max 64 characters)
 * @param p_description     Optional description of the equipment (max 2048 characters)
 * @param p_availability    Required availability information (max 2048 characters)
 *                          Describes when and how the equipment is available
 * @param p_institution_id  Required UUID of the institution that owns the equipment
 *                          Must reference an existing institution record
 * 
 * @throws SQLSTATE '23000' if institution_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if equipment_id already exists (primary key constraint)
 */
DROP PROCEDURE IF EXISTS create_equipment;
CREATE PROCEDURE create_equipment(
    IN p_equipment_id CHAR(36),
    IN p_name VARCHAR(64),
    IN p_description VARCHAR(2048),
    IN p_availability VARCHAR(2048),
    IN p_institution_id CHAR(36)    
)
BEGIN
    INSERT INTO equipment (
        equipment_id, 
        name, 
        description,
        availability, 
        institution_id
    ) VALUES (
        p_equipment_id, 
        p_name, 
        p_description, 
        p_availability, 
        p_institution_id)
    ;
END $$

DELIMITER ;

-- Source: create/create_faculty.sql

DELIMITER $$

/**
 * Creates a new faculty member record in the database.
 * 
 * Inserts a new faculty record with the provided information.
 * Only first_name & faculty_id are required; all other fields are optional.
 * 
 * @param p_faculty_id          Required UUID for the faculty member
 * @param p_first_name          Required first name of the faculty member
 * @param p_last_name           Optional last name
 * @param p_biography           Optional biography text (max 2048 chars)
 * @param p_orcid               Optional ORCID identifier (19 characters)
 * @param p_google_scholar_url  Optional Google Scholar profile URL
 * @param p_research_gate_url   Optional ResearchGate profile URL
 * @param p_scraped_from        Optional source URL if data was scraped
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the newly created faculty member
 * 
 * @throws SQLSTATE '45000' if first_name is NULL
 */
DROP PROCEDURE IF EXISTS create_faculty;
CREATE PROCEDURE create_faculty (
    IN p_faculty_id          CHAR(36),
    IN p_first_name          VARCHAR(128),
    IN p_last_name           VARCHAR(128),
    IN p_biography           VARCHAR(2048),
    IN p_orcid               CHAR(19),
    IN p_google_scholar_url  VARCHAR(255),
    IN p_research_gate_url   VARCHAR(255),
    IN p_scraped_from        VARCHAR(255)
)
BEGIN

    -- Validate that faculty_id is provided (required field)
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required when creating a faculty record';
    END IF;

    -- Validate that first_name is provided (required field)
    IF p_first_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'first_name is required when creating a faculty record';
    END IF;

    -- Insert the new faculty record with all provided information
    -- NULL values are allowed for optional fields (last_name, biography, etc.)
    INSERT INTO faculty (
        faculty_id,
        first_name,
        last_name,
        biography,
        orcid,
        google_scholar_url,
        research_gate_url,
        scraped_from
    )
    VALUES (
        p_faculty_id,
        p_first_name,
        p_last_name,
        p_biography,
        p_orcid,
        p_google_scholar_url,
        p_research_gate_url,
        p_scraped_from
    );

    -- Return the faculty_id so the caller knows the new faculty member's identifier
    SELECT p_faculty_id AS faculty_id;
END $$

DELIMITER ;


-- Source: create/create_faculty_department.sql

DELIMITER $$

/**
 * Associates a department with a faculty member.
 * 
 * Inserts a new department association for the specified faculty member.
 * Faculty members can belong to multiple departments, so this creates an
 * additional department association rather than replacing existing ones.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_department_name Required name of the department
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - department_name: The department name that was inserted
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if faculty_id or department_name is NULL
 */
CREATE PROCEDURE create_faculty_department (
    IN p_faculty_id CHAR(36),
    IN p_department_name VARCHAR(128)
)
BEGIN
    -- Validate that both required parameters are provided
    IF p_faculty_id IS NULL OR p_department_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and department_name are required.';
    END IF;

    -- Insert a new department association for the faculty member
    -- Faculty can belong to multiple departments (e.g., joint appointments)
    -- The combination of faculty_id and department_name should be unique
    INSERT INTO faculty_department (faculty_id, department_name)
    VALUES (p_faculty_id, p_department_name);

    -- Return confirmation with the inserted values
    SELECT p_faculty_id AS faculty_id,
           p_department_name AS department_name,
           'inserted' AS action;
END $$

DELIMITER ;

-- Source: create/create_faculty_email.sql

DELIMITER $$

/**
 * Adds an email address to a faculty member.
 * 
 * Inserts a new email record for the specified faculty member. Faculty
 * members can have multiple email addresses, so this creates an additional
 * email association rather than replacing existing ones.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_email       Required email address to associate with the faculty member
 * 
 * @returns No result set (unlike other create procedures)
 */
CREATE PROCEDURE create_faculty_email (
    IN p_faculty_id CHAR(36),
    IN p_email      VARCHAR(255)
)
BEGIN
    -- Insert a new email address for the faculty member
    -- Faculty can have multiple email addresses (e.g., work, personal, lab)
    -- The combination of faculty_id and email should be unique
    -- Note: This procedure does not return a result set (unlike other create procedures)
    INSERT INTO faculty_email (faculty_id, email)
    VALUES (p_faculty_id, p_email);
END$$

DELIMITER ;

-- Source: create/create_faculty_follows_faculty.sql

DELIMITER $$

/**
 * Creates a follow relationship between two faculty members.
 * 
 * Inserts a new follow relationship where one faculty member (follower)
 * follows another faculty member (followee). A faculty member cannot
 * follow themselves.
 * 
 * @param p_follower_id  Required UUID of the faculty member who is following
 * @param p_followee_id  Required UUID of the faculty member being followed
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if follower_id or followee_id is NULL, if they are the same, or if either faculty doesn't exist
 */
CREATE PROCEDURE create_faculty_follows_faculty (
    IN p_follower_id CHAR(36),
    IN p_followee_id CHAR(36)
)
BEGIN
    DECLARE follower_exists INT;
    DECLARE followee_exists INT;

    -- Validate that both required parameters are provided
    IF p_follower_id IS NULL OR p_followee_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'follower_id and followee_id are required.';
    END IF;

    -- Prevent a faculty member from following themselves
    IF p_follower_id = p_followee_id THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'A faculty member cannot follow themselves.';
    END IF;

    -- Verify that the follower exists
    SELECT COUNT(*) INTO follower_exists
    FROM faculty
    WHERE faculty_id = p_follower_id;

    IF follower_exists = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'follower_id does not exist.';
    END IF;

    -- Verify that the followee exists
    SELECT COUNT(*) INTO followee_exists
    FROM faculty
    WHERE faculty_id = p_followee_id;

    IF followee_exists = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'followee_id does not exist.';
    END IF;

    -- Insert the follow relationship
    -- The composite primary key ensures uniqueness (a faculty can only follow another faculty once)
    INSERT INTO faculty_follows_faculty (follower_id, followee_id)
    VALUES (p_follower_id, p_followee_id);

    -- Return confirmation with the inserted values
    SELECT p_follower_id AS follower_id,
           p_followee_id AS followee_id,
           'inserted' AS action;
END $$

DELIMITER ;


-- Source: create/create_faculty_generates_keyword.sql

DELIMITER $$

/**
 * Creates a new faculty keyword generation record.
 * 
 * Inserts a record tracking when a faculty member requested keyword generation
 * using an LLM. This is used to enforce rate limiting on LLM usage.
 * 
 * @param p_generation_id  Required UUID for the generation record
 * @param p_faculty_id     Required UUID of the faculty member making the request
 *                         Must reference an existing faculty record
 * @param p_generated_at   Optional timestamp of when the request was made
 *                         If NULL, uses current timestamp
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
* @throws SQLSTATE '45000' if generation_id or faculty_id is NULL
 */
CREATE PROCEDURE create_faculty_generates_keyword(
    IN p_generation_id CHAR(36),
    IN p_faculty_id CHAR(36),
    IN p_generated_at DATETIME
)
BEGIN
    -- Validate required parameters
    IF p_generation_id IS NULL OR TRIM(p_generation_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'generation_id is required for create_faculty_generates_keyword';
    END IF;

    IF p_faculty_id IS NULL OR TRIM(p_faculty_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required for create_faculty_generates_keyword';
    END IF;

    -- Insert record, using current timestamp if p_generated_at is NULL
    INSERT INTO faculty_generates_keyword (generation_id, faculty_id, generated_at)
    VALUES (p_generation_id, p_faculty_id, COALESCE(p_generated_at, NOW()));
END $$

DELIMITER ;



-- Source: create/create_faculty_phone.sql

DELIMITER $$

/**
 * Adds a phone number to a faculty member.
 * 
 * Inserts a new phone number record for the specified faculty member.
 * Faculty members can have multiple phone numbers, so this creates an
 * additional phone number association rather than replacing existing ones.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_phone_num   Required phone number to associate with the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - phone_num: The phone number that was inserted
 *   - action: Status message ('inserted')
 */
CREATE PROCEDURE create_faculty_phone (
    IN p_faculty_id CHAR(36),
    IN p_phone_num  VARCHAR(32)
)
BEGIN
    -- Insert a new phone number for the faculty member
    -- Faculty can have multiple phone numbers (e.g., office, mobile, lab)
    -- The combination of faculty_id and phone_num should be unique
    INSERT INTO faculty_phone (faculty_id, phone_num)
    VALUES (p_faculty_id, p_phone_num);

    -- Return confirmation with the inserted values
    SELECT p_faculty_id AS faculty_id,
           p_phone_num AS phone_num,
           'inserted' AS action;
END$$

DELIMITER ;

-- Source: create/create_faculty_researches_keyword.sql

DELIMITER $$

/**
 * Associates a keyword with a faculty member's research interests.
 * 
 * Inserts a record into the faculty_researches_keyword join table, establishing
 * that a specific faculty member researches a specific keyword. This allows
 * faculty members to have multiple research interests and enables searching
 * faculty by their research areas.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 *                      Must reference an existing faculty record
 * @param p_name        Required keyword name (max 64 characters)
 *                      Must reference an existing keyword record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if keyword name doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the faculty-keyword association already exists (unique constraint)
 */
CREATE PROCEDURE create_faculty_researches_keyword(
    IN p_faculty_id CHAR(36),
    IN p_name VARCHAR(64)
)
BEGIN
    INSERT INTO faculty_researches_keyword (name, faculty_id)
    VALUES (p_name, p_faculty_id);
END $$

DELIMITER ;


-- Source: create/create_faculty_title.sql

DELIMITER $$

/**
 * Adds a title to a faculty member.
 * 
 * Inserts a new title record for the specified faculty member. Faculty members
 * can have multiple titles, so this creates an additional title association
 * rather than replacing existing ones.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_title       Required title to associate with the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - title: The title that was inserted
 *   - action: Status message ('inserted')
 */
CREATE PROCEDURE create_faculty_title (
    IN p_faculty_id CHAR(36),
    IN p_title      VARCHAR(255)
)
BEGIN
    -- Insert a new title association for the faculty member
    -- This allows faculty to have multiple titles (e.g., "Professor", "Department Chair")
    -- The combination of faculty_id and title should be unique
    INSERT INTO faculty_title (faculty_id, title)
    VALUES (p_faculty_id, p_title);

    -- Return confirmation with the inserted values
    SELECT p_faculty_id AS faculty_id,
           p_title AS title,
           'inserted' AS action;
END$$

DELIMITER ;

-- Source: create/create_faculty_works_at_institution.sql

DELIMITER $$

/**
 * Creates a new faculty-institution relationship record in the database.
 * 
 * Inserts a new faculty_works_at_institution record establishing a relationship
 * between a faculty member and an institution. This represents an employment
 * period, with a start date (required) and optional end date. The composite
 * primary key (faculty_id, institution_id, start_date) must be unique.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 *                          Must reference an existing faculty record
 * @param p_institution_id  Required UUID of the institution
 *                          Must reference an existing institution record
 * @param p_start_date      Required start date of the employment relationship
 *                          Part of the composite primary key
 * @param p_end_date        Optional end date of the employment relationship
 *                          NULL indicates the faculty member currently works at the institution
 * 
 * @returns No result set. Use read_faculty_works_at_institution to verify the insert.
 * 
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if institution_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if a record with the same (faculty_id, institution_id, start_date) already exists
 */
DROP PROCEDURE IF EXISTS create_faculty_works_at_institution;
CREATE PROCEDURE create_faculty_works_at_institution(
    IN p_faculty_id CHAR(36),
    IN p_institution_id CHAR(36),
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    INSERT INTO faculty_works_at_institution(
        faculty_id, 
        institution_id, 
        start_date, 
        end_date
    ) VALUES (
        p_faculty_id, 
        p_institution_id, 
        p_start_date, 
        p_end_date
    );
END $$

DELIMITER ;

-- Source: create/create_grants.sql

DELIMITER $$

/**
 * Creates a new grant record in the database.
 * 
 * Inserts a new grant record with the provided information. Grants represent
 * funding awards with a specific amount, description, and time period.
 * 
 * @param p_grant_id      Required UUID for the grant record
 * @param p_description   Optional description of the grant (TEXT field)
 * @param p_amount        Required grant amount (DECIMAL with 10 digits, 2 decimal places)
 * @param p_start_date    Required start date of the grant period
 * @param p_end_date      Optional end date of the grant period (NULL if ongoing)
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if grant_id already exists (primary key constraint)
 */
DROP PROCEDURE IF EXISTS create_grants;
CREATE PROCEDURE create_grants(
    IN      p_grant_id      CHAR(36),
    IN      p_description   TEXT,
    IN      p_amount        DECIMAL(10,2),
    IN      p_start_date    DATE,
    IN      p_end_date      DATE
)

BEGIN
    INSERT INTO grants(
        grant_id, description, amount, start_date, end_date
    ) VALUES (
        p_grant_id, p_description, p_amount, p_start_date, p_end_date
    );
END $$

DELIMITER ;


-- Source: create/create_grants_for_keyword.sql

DELIMITER $$

/**
 * Associates a grant with a keyword.
 * 
 * Inserts a record into the grants_for_keyword join table, establishing
 * that a specific grant is related to a specific keyword. This allows
 * grants to be categorized and searched by research keywords.
 * 
 * @param p_grant_id  Required UUID of the grant
 *                    Must reference an existing grant record
 * @param p_name      Required keyword name (max 64 characters)
 *                    Must reference an existing keyword record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if grant_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if keyword name doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the grant-keyword association already exists (unique constraint)
 */
DROP PROCEDURE IF EXISTS create_grants_for_keyword;
CREATE PROCEDURE create_grants_for_keyword(
    IN p_grant_id  CHAR(36),
    IN p_name      VARCHAR(64)
)
BEGIN
    INSERT INTO grants_for_keyword(grant_id, name) 
    VALUES(p_grant_id, p_name);
END $$
DELIMITER ;


-- Source: create/create_grants_granted_to_faculty.sql

DELIMITER $$

/**
 * Associates a grant with a faculty member.
 * 
 * Inserts a record into the grants_granted_to_faculty join table, establishing
 * that a specific faculty member is a recipient of a specific grant. This
 * allows tracking which faculty members have received which grants.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 *                      Must reference an existing faculty record
 * @param p_grant_id    Required UUID of the grant
 *                      Must reference an existing grant record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if grant_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the faculty-grant association already exists (unique constraint)
 */
DROP PROCEDURE IF EXISTS create_grants_granted_to_faculty;
CREATE PROCEDURE create_grants_granted_to_faculty(
    IN p_faculty_id    CHAR(36),
    IN p_grant_id      CHAR(36)
)
BEGIN
    INSERT INTO grants_granted_to_faculty(faculty_id, grant_id)
    VALUES(p_faculty_id, p_grant_id);
END $$
DELIMITER ;


-- Source: create/create_institution.sql

DELIMITER $$

/**
 * Creates a new institution record in the database.
 * 
 * Inserts a new institution record with the provided information. The institution_id
 * and name are required, along with country. All other location and contact fields
 * are optional. The zip code must be exactly 5 digits if provided.
 * 
 * @param p_institution_id  Required UUID for the institution record
 * @param p_name            Required institution name (max 256 characters)
 * @param p_street_addr     Optional street address (max 255 characters)
 * @param p_city            Optional city name (max 255 characters)
 * @param p_state           Optional state or province (max 255 characters)
 * @param p_country         Required country name (max 255 characters)
 * @param p_zip             Optional postal code (must be exactly 5 digits if provided)
 * @param p_website_url     Optional website URL (max 255 characters)
 * @param p_type            Optional institution type (ENUM: 'Public University', 'Private University', 'Community College')
 * 
 * @returns No result set. Use read_institution to verify the insert.
 * 
 * @throws SQLSTATE '23000' if institution_id already exists (primary key constraint)
 * @throws SQLSTATE 'HY000' if zip code format is invalid (must be 5 digits)
 */
DROP PROCEDURE IF EXISTS create_institution;
CREATE PROCEDURE create_institution(
    IN p_institution_id CHAR(36),
    IN p_name VARCHAR(256),
    IN p_street_addr VARCHAR(255),
    IN p_city VARCHAR(255),
    IN p_state VARCHAR(255),
    IN p_country VARCHAR(255),
    IN p_zip VARCHAR(16),
    IN p_website_url VARCHAR(255),
    IN p_type VARCHAR(64)
)
BEGIN
    INSERT INTO institution (
        institution_id,
        name,
        street_addr,
        city,
        state,
        country,
        zip,
        website_url,
        type
    ) VALUES (
        p_institution_id,
        p_name,
        p_street_addr,
        p_city,
        p_state,
        p_country,
        p_zip,
        p_website_url,
        p_type
    );
END $$

DELIMITER ;


-- Source: create/create_keyword.sql

DELIMITER $$

/**
 * Creates a new keyword record in the database.
 * 
 * Inserts a new keyword with the provided name. Keywords are used to tag
 * and categorize research areas, publications, and faculty interests.
 * 
 * @param p_name  Required keyword name (max 64 characters)
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if a keyword with the same name already exists (unique constraint)
 */
CREATE PROCEDURE create_keyword(
    IN p_name VARCHAR(64)
)
BEGIN
    INSERT INTO keyword (name)
    VALUES (p_name);
END $$

DELIMITER ;


-- Source: create/create_publication.sql

DELIMITER $$

/**
 * Creates a new publication record in the database.
 * 
 * Inserts a new publication with the provided information. Publications
 * represent scholarly works such as papers, articles, books, etc. The
 * citation_count is automatically initialized to 0.
 * 
 * @param p_id         Required UUID for the publication record
 * @param p_title      Required publication title (max 64 characters)
 * @param p_publisher  Optional publisher name (max 255 characters)
 * @param p_year       Optional publication year (INT)
 * @param p_doi        Optional Digital Object Identifier (max 64 characters)
 * @param p_abstract   Optional abstract text (TEXT field)
 * @param p_citation_count Optional citation count (INT)
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if publication_id already exists (primary key constraint)
 */
CREATE PROCEDURE create_publication(
    IN p_id CHAR(36),
    IN p_title VARCHAR(64),
    IN p_publisher VARCHAR(255),
    IN p_year INT,
    IN p_doi VARCHAR(64),
    IN p_abstract TEXT,
    IN p_citation_count INT
)
BEGIN
    -- Validate input: publication_id must be provided
    IF p_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'publication_id is required.';
    END IF;

    INSERT INTO publication (publication_id, title, publisher, year, doi, abstract, citation_count)
    VALUES (p_id, p_title, p_publisher, p_year, p_doi, p_abstract, p_citation_count);
END $$
DELIMITER ;


-- Source: create/create_publication_authored_by_faculty.sql

DELIMITER $$

/**
 * Creates an association between a faculty member and a publication.
 * 
 * Inserts a record into the publication_authored_by_faculty join table,
 * establishing that a specific faculty member authored a specific publication.
 * This allows many-to-many relationships between faculty and publications.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_publication_id  Required UUID of the publication
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - publication_id: UUID of the publication
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if faculty_id or publication_id is NULL
 */
CREATE PROCEDURE create_publication_authored_by_faculty (
    IN p_faculty_id CHAR(36),
    IN p_publication_id CHAR(36)
)
BEGIN
    -- Validate that both IDs are provided (neither can be NULL)
    IF p_faculty_id IS NULL OR p_publication_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and publication_id are required.';
    END IF;

    -- Insert the relationship into the join table
    -- This creates a link between a faculty member and a publication
    -- Note: If this relationship already exists, this will fail due to unique constraint
    INSERT INTO publication_authored_by_faculty (faculty_id, publication_id)
    VALUES (p_faculty_id, p_publication_id);

    -- Return confirmation with both IDs to verify the relationship was created
    SELECT p_faculty_id AS faculty_id,
           p_publication_id AS publication_id,
           'inserted' AS action;
END $$
DELIMITER ;


-- Source: create/create_publication_explores_keyword.sql

DELIMITER $$

/**
 * Associates a keyword with a publication.
 * 
 * Inserts a record into the publication_explores_keyword join table, establishing
 * that a specific publication explores or is related to a specific keyword.
 * This allows publications to be tagged with multiple keywords for categorization
 * and searching.
 * 
 * @param p_publication_id  Required UUID of the publication
 *                          Must reference an existing publication record
 * @param p_name            Required keyword name (max 64 characters)
 *                          Must reference an existing keyword record
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if publication_id doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if keyword name doesn't exist (foreign key constraint)
 * @throws SQLSTATE '23000' if the publication-keyword association already exists (unique constraint)
 */
CREATE PROCEDURE create_publication_explores_keyword(
    IN p_publication_id CHAR(36),
    IN p_name VARCHAR(64)
)
BEGIN
    INSERT INTO publication_explores_keyword(publication_id, name)
    VALUES (p_publication_id, p_name);
END $$

DELIMITER ;


-- Source: create/create_session.sql

DELIMITER $$

/**
 * Creates a new session record in the database.
 * 
 * Inserts a new session with a hashed refresh token for long-term authentication.
 * Sessions are used to maintain user login state across browser sessions.
 * The refresh token is hashed using SHA-256 before storage for security.
 * 
 * @param p_session_id    Required UUID for the session record
 * @param p_faculty_id    Required UUID of the faculty member
 * @param p_token_hash     Required SHA-256 hash of the refresh token (64 characters)
 * @param p_expires_at     Required expiration datetime for the session
 * 
 * @returns No result set. Use read procedures to verify the insert.
 * 
 * @throws SQLSTATE '23000' if session_id or token_hash already exists (unique constraint)
 * @throws SQLSTATE '23000' if faculty_id doesn't exist (foreign key constraint)
 */
DROP PROCEDURE IF EXISTS create_session;
CREATE PROCEDURE create_session(
    IN p_session_id CHAR(36),
    IN p_faculty_id CHAR(36),
    IN p_token_hash VARCHAR(64),
    IN p_expires_at DATETIME
)
BEGIN
    -- Validate required fields
    IF p_session_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'session_id is required';
    END IF;

    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required';
    END IF;

    IF p_token_hash IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'token_hash is required';
    END IF;

    IF p_expires_at IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'expires_at is required';
    END IF;

    -- Insert session record
    INSERT INTO session (
        session_id,
        faculty_id,
        token_hash,
        created_at,
        expires_at,
        revoked
    )
    VALUES (
        p_session_id,
        p_faculty_id,
        p_token_hash,
        UTC_TIMESTAMP(),
        p_expires_at,
        FALSE
    );
END $$

DELIMITER ;



-- ============================================================
-- read procedures
-- ============================================================

-- Source: read/read_equipment.sql

DELIMITER $$

/**
 * Retrieves equipment records from the database with optional filtering.
 * 
 * Returns equipment information based on the provided filters. If both
 * parameters are NULL, all equipment records in the database are returned.
 * Results are ordered alphabetically by equipment name.
 * 
 * @param p_equipment_id     Optional UUID of a specific equipment item to retrieve.
 *                          When provided, only that equipment record is returned.
 * @param p_institution_id  Optional UUID of an institution to filter by.
 *                          When provided, only equipment belonging to that institution is returned.
 * 
 * @returns Result set containing all columns from the equipment table:
 *   - equipment_id
 *   - name
 *   - description
 *   - availability
 *   - institution_id
 * 
 * If both parameters are NULL, returns all equipment records ordered by name.
 */
CREATE PROCEDURE read_equipment (
    IN p_equipment_id   CHAR(36),
    IN p_institution_id CHAR(36)
)
BEGIN
    SELECT e.*
    FROM equipment e
    WHERE (p_equipment_id IS NULL OR e.equipment_id = p_equipment_id)
      AND (p_institution_id IS NULL OR e.institution_id = p_institution_id)
    ORDER BY e.name;
END $$

DELIMITER ;


-- Source: read/read_faculty.sql

DELIMITER $$

/**
 * Retrieves a faculty member record by their ID.
 * 
 * Fetches all information for a specific faculty member identified by
 * their unique faculty_id.
 * 
 * @param p_faculty_id  Required UUID of the faculty member to retrieve
 * 
 * @returns Result set containing all columns from the faculty table:
 *   - faculty_id
 *   - first_name
 *   - last_name
 *   - biography
 *   - orcid
 *   - google_scholar_url
 *   - research_gate_url
 *   - scraped_from
 */
CREATE PROCEDURE read_faculty(
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Simple SELECT query to retrieve all columns for the specified faculty member
    -- Uses table alias 'f' for clarity
    -- Returns all fields from the faculty table for the matching ID
    SELECT f.*
    FROM faculty f
    WHERE f.faculty_id = p_faculty_id;
END $$
DELIMITER ;


-- Source: read/read_faculty_department.sql

DELIMITER $$

/**
 * Retrieves all department records from the database.
 * 
 * Returns all records from the faculty_department table.
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - department_name: Department name
 * 
 * Results are ordered by faculty_id, then department_name.
 */
DROP PROCEDURE IF EXISTS read_faculty_department;
CREATE PROCEDURE read_faculty_department()
BEGIN
    SELECT faculty_id, department_name
    FROM faculty_department
    ORDER BY faculty_id, department_name;
END $$

DELIMITER ;



-- Source: read/read_faculty_department_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all departments associated with a faculty member.
 * 
 * Returns all department records for the specified faculty member. Since
 * faculty members can belong to multiple departments, this may return
 * multiple rows.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - department_name: One department name associated with the faculty member
 *   (Multiple rows if the faculty member belongs to multiple departments)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_department_by_faculty;
CREATE PROCEDURE read_faculty_department_by_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Validate that faculty_id is provided
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required.';
    END IF;

    -- Retrieve all departments for the specified faculty member
    -- Returns multiple rows if the faculty member belongs to multiple departments
    -- Each row represents one department association
    -- Only returns department_name (not faculty_id) since it's already known
    SELECT department_name
    FROM faculty_department
    WHERE faculty_id = p_faculty_id;
END $$

DELIMITER ;

-- Source: read/read_faculty_email.sql

DELIMITER $$

/**
 * Retrieves all email records from the database.
 * 
 * Returns all records from the faculty_email table.
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - email: Email address
 * 
 * Results are ordered by faculty_id, then email.
 */
DROP PROCEDURE IF EXISTS read_faculty_email;
CREATE PROCEDURE read_faculty_email()
BEGIN
    SELECT faculty_id, email
    FROM faculty_email
    ORDER BY faculty_id, email;
END $$

DELIMITER ;



-- Source: read/read_faculty_email_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all email addresses associated with a faculty member.
 * 
 * Returns all email records for the specified faculty member. Since
 * faculty members can have multiple email addresses, this may return
 * multiple rows.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - email: One email address associated with the faculty member
 *   (Multiple rows if the faculty member has multiple email addresses)
 */
DROP PROCEDURE IF EXISTS read_faculty_email_by_faculty;
CREATE PROCEDURE read_faculty_email_by_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Retrieve all email addresses for the specified faculty member
    -- Returns multiple rows if the faculty member has multiple email addresses
    -- Each row represents one email address association
    SELECT faculty_id, email
    FROM faculty_email
    WHERE faculty_id = p_faculty_id;
END$$

DELIMITER ;

-- Source: read/read_faculty_follows_faculty.sql

DELIMITER $$

/**
 * Retrieves all follow relationships from the database.
 * 
 * Returns all records from the faculty_follows_faculty table, showing
 * all follow relationships between faculty members.
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 * 
 * Results are ordered by follower_id, then followee_id.
 */
DROP PROCEDURE IF EXISTS read_faculty_follows_faculty;
CREATE PROCEDURE read_faculty_follows_faculty()
BEGIN
    SELECT 
        follower_id,
        followee_id
    FROM faculty_follows_faculty
    ORDER BY follower_id, followee_id;
END $$

DELIMITER ;



-- Source: read/read_faculty_follows_faculty_by_followee.sql

DELIMITER $$

/**
 * Retrieves all faculty members who follow a given faculty member.
 * 
 * Returns all follow relationships where the specified faculty member
 * is the followee. This shows who is following the faculty member.
 * 
 * @param p_faculty_id  Required UUID of the faculty member (followee)
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 *   (Multiple rows if multiple people follow the faculty member)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_follows_faculty_by_followee;
CREATE PROCEDURE read_faculty_follows_faculty_by_followee (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Validate that faculty_id is provided
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required.';
    END IF;

    -- Retrieve all follow relationships where the specified faculty member is the followee
    -- Returns multiple rows if multiple people follow the faculty member
    -- Each row represents one follow relationship
    SELECT follower_id, followee_id
    FROM faculty_follows_faculty
    WHERE followee_id = p_faculty_id;
END $$
DELIMITER ;



-- Source: read/read_faculty_follows_faculty_by_follower.sql

DELIMITER $$

/**
 * Retrieves all faculty members that a given faculty member follows.
 * 
 * Returns all follow relationships where the specified faculty member
 * is the follower. This shows who the faculty member is following.
 * 
 * @param p_faculty_id  Required UUID of the faculty member (follower)
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who is following
 *   - followee_id: UUID of the faculty member being followed
 *   (Multiple rows if the faculty member follows multiple people)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_follows_faculty_by_follower;
CREATE PROCEDURE read_faculty_follows_faculty_by_follower (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Validate that faculty_id is provided
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required.';
    END IF;

    -- Retrieve all follow relationships where the specified faculty member is the follower
    -- Returns multiple rows if the faculty member follows multiple people
    -- Each row represents one follow relationship
    SELECT follower_id, followee_id
    FROM faculty_follows_faculty
    WHERE follower_id = p_faculty_id;
END $$

DELIMITER ;


-- Source: read/read_faculty_generates_keyword.sql

DELIMITER $$

/**
 * Retrieves faculty keyword generation records.
 * 
 * Fetches records of when faculty members requested keyword generation.
 * Can filter by faculty_id and optionally by time range for rate limiting checks.
 * 
 * @param p_generation_id  Optional UUID of a specific generation record to retrieve
 *                         If provided, returns only that record
 * @param p_faculty_id     Optional UUID of the faculty member
 *                         If provided, returns all generation records for that faculty
 * @param p_start_date     Optional start date for filtering by time range
 *                         If provided with p_end_date, returns records within range
 * @param p_end_date       Optional end date for filtering by time range
 *                         If provided with p_start_date, returns records within range
 * 
 * @returns Result set containing:
 *   - generation_id: UUID of the generation record
 *   - faculty_id: UUID of the faculty member
 *   - generated_at: Timestamp when the request was made
 * 
 * If both p_generation_id and p_faculty_id are NULL, returns an error.
 * Results are ordered by generated_at descending (most recent first).
 */
CREATE PROCEDURE read_faculty_generates_keyword(
    IN p_generation_id CHAR(36),
    IN p_faculty_id CHAR(36),
    IN p_start_date DATETIME,
    IN p_end_date DATETIME
)
BEGIN

    IF p_generation_id IS NULL AND p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Either generation_id or faculty_id must be provided for read_faculty_generates_keyword';
    END IF;

    SELECT 
        generation_id,
        faculty_id,
        generated_at
    FROM faculty_generates_keyword
    WHERE 
        (p_generation_id IS NULL OR generation_id = p_generation_id)
        AND (p_faculty_id IS NULL OR faculty_id = p_faculty_id)
        AND (p_start_date IS NULL OR generated_at >= p_start_date)
        AND (p_end_date IS NULL OR generated_at <= p_end_date)
    ORDER BY generated_at DESC;
END $$

DELIMITER ;



-- Source: read/read_faculty_phone.sql

DELIMITER $$

/**
 * Retrieves all phone number records from the database.
 * 
 * Returns all records from the faculty_phone table.
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - phone_num: Phone number
 * 
 * Results are ordered by faculty_id, then phone_num.
 */
DROP PROCEDURE IF EXISTS read_faculty_phone;
CREATE PROCEDURE read_faculty_phone()
BEGIN
    SELECT faculty_id, phone_num
    FROM faculty_phone
    ORDER BY faculty_id, phone_num;
END $$

DELIMITER ;



-- Source: read/read_faculty_phone_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all phone numbers associated with a faculty member.
 * 
 * Returns all phone number records for the specified faculty member.
 * Since faculty members can have multiple phone numbers, this may return
 * multiple rows.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - phone_num: One phone number associated with the faculty member
 *   (Multiple rows if the faculty member has multiple phone numbers)
 */
DROP PROCEDURE IF EXISTS read_faculty_phone_by_faculty;
CREATE PROCEDURE read_faculty_phone_by_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Retrieve all phone numbers for the specified faculty member
    -- Returns multiple rows if the faculty member has multiple phone numbers
    -- Each row represents one phone number association
    SELECT faculty_id, phone_num
    FROM faculty_phone
    WHERE faculty_id = p_faculty_id;
END$$

DELIMITER ;

-- Source: read/read_faculty_researches_keyword_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all research keywords associated with a faculty member.
 * 
 * Returns all keyword names that the specified faculty member researches.
 * This shows the research interests/areas for the faculty member.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - name: Keyword name (max 64 characters)
 *   (Multiple rows if the faculty member researches multiple keywords)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_researches_keyword_by_faculty;
CREATE PROCEDURE read_faculty_researches_keyword_by_faculty(
    IN p_faculty_id CHAR(36)
)
BEGIN
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required';
    END IF;

    SELECT name
    FROM faculty_researches_keyword
    WHERE faculty_id = p_faculty_id;
END $$
DELIMITER ;


-- Source: read/read_faculty_title.sql

DELIMITER $$

/**
 * Retrieves all title records from the database.
 * 
 * Returns all records from the faculty_title table.
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - title: Title
 * 
 * Results are ordered by faculty_id, then title.
 */
DROP PROCEDURE IF EXISTS read_faculty_title;
CREATE PROCEDURE read_faculty_title()
BEGIN
    SELECT faculty_id, title
    FROM faculty_title
    ORDER BY faculty_id, title;
END $$

DELIMITER ;



-- Source: read/read_faculty_title_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all titles associated with a faculty member.
 * 
 * Returns all title records for the specified faculty member. Since faculty
 * members can have multiple titles, this may return multiple rows.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - title: One title associated with the faculty member
 *   (Multiple rows if the faculty member has multiple titles)
 */
DROP PROCEDURE IF EXISTS read_faculty_title_by_faculty;
CREATE PROCEDURE read_faculty_title_by_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Retrieve all titles for the specified faculty member
    -- Returns multiple rows if the faculty member has multiple titles
    -- Each row represents one title association
    SELECT faculty_id, title
    FROM faculty_title
    WHERE faculty_id = p_faculty_id;
END$$

DELIMITER ;

-- Source: read/read_faculty_works_at_institution.sql

DELIMITER $$

/**
 * Retrieves all faculty-institution relationship records from the database.
 * 
 * Returns all records from the faculty_works_at_institution table.
 * Results are ordered by faculty_id, institution_id, and start_date (descending).
 * 
 * @returns Result set containing all columns from the faculty_works_at_institution table:
 *   - faculty_id
 *   - institution_id
 *   - start_date
 *   - end_date
 */
DROP PROCEDURE IF EXISTS read_faculty_works_at_institution;
CREATE PROCEDURE read_faculty_works_at_institution()
BEGIN
    SELECT fwi.*
    FROM faculty_works_at_institution fwi
    ORDER BY fwi.faculty_id, fwi.institution_id, fwi.start_date DESC;
END $$

DELIMITER ;



-- Source: read/read_faculty_works_at_institution_by_faculty.sql

DELIMITER $$

/**
 * Retrieves faculty-institution relationship records from the database.
 * 
 * Returns faculty_works_at_institution records based on optional filters.
 * This is an alias/alternative name for read_faculty_works_at_institution.
 * If both parameters are NULL, all relationship records are returned.
 * Results are ordered by faculty_id, institution_id, and start_date (descending).
 * 
 * @param p_faculty_id      Optional UUID of a faculty member to filter by.
 *                         When provided, only relationships for that faculty member are returned.
 * @param p_institution_id  Optional UUID of an institution to filter by.
 *                         When provided, only relationships for that institution are returned.
 * 
 * @returns Result set containing all columns from the faculty_works_at_institution table:
 *   - faculty_id
 *   - institution_id
 *   - start_date
 *   - end_date
 * 
 * If both parameters are NULL, returns all relationship records.
 */
DROP PROCEDURE IF EXISTS read_faculty_works_at_institution_by_faculty;
CREATE PROCEDURE read_faculty_works_at_institution_by_faculty (
    IN p_faculty_id      CHAR(36),
    IN p_institution_id  CHAR(36)
)
BEGIN
    SELECT fwi.*
    FROM faculty_works_at_institution fwi
    WHERE (p_faculty_id IS NULL OR fwi.faculty_id = p_faculty_id)
      AND (p_institution_id IS NULL OR fwi.institution_id = p_institution_id)
    ORDER BY fwi.faculty_id, fwi.institution_id, fwi.start_date DESC;
END $$

DELIMITER ;


-- Source: read/read_faculty_works_at_institution_by_institution.sql

DELIMITER $$

/**
 * Retrieves all faculty members who work at a given institution.
 * 
 * Returns all faculty records associated with the specified institution.
 * This includes faculty members who currently work at the institution or
 * have worked there in the past (based on the faculty_works_at_institution
 * relationship table).
 * 
 * @param p_institution_id  Required UUID of the institution
 * 
 * @returns Result set containing all columns from the faculty table:
 *   - faculty_id
 *   - first_name
 *   - last_name
 *   - biography
 *   - orcid
 *   - google_scholar_url
 *   - research_gate_url
 *   - scraped_from
 * 
 * @throws SQLSTATE '45000' if institution_id is NULL
 */
DROP PROCEDURE IF EXISTS read_faculty_works_at_institution_by_institution;
CREATE PROCEDURE read_faculty_works_at_institution_by_institution (
    IN p_institution_id CHAR(36)
)
BEGIN
    -- Validate that institution_id is provided
    IF p_institution_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'institution_id is required';
    END IF;

    -- Retrieve all faculty members associated with the specified institution
    -- Joins faculty_works_at_institution to find all faculty at this institution
    -- Returns all faculty information for those who work or have worked at the institution
    SELECT f.*
    FROM faculty f
    INNER JOIN faculty_works_at_institution fwi
        ON f.faculty_id = fwi.faculty_id
    WHERE fwi.institution_id = p_institution_id
    ORDER BY f.last_name, f.first_name;
END $$

DELIMITER ;


-- Source: read/read_grants_by_organization.sql

DELIMITER $$

/**
 * Retrieves all grants associated with a specific organization.
 * 
 * Returns all grant records associated with the specified organization
 * through the grants_organization join table. Includes a derived status
 * field indicating whether each grant is active, expired, or upcoming.
 * 
 * @param p_name  Required organization name (max 256 characters)
 * 
 * @returns Result set containing all columns from the grants table plus:
 *   - grant_id
 *   - description
 *   - amount
 *   - start_date
 *   - end_date
 *   - derived_status: Computed status ('Active', 'Expired', or 'Upcoming')
 * 
 * Results are ordered by start_date (newest first).
 * 
 * @throws SQLSTATE '45000' if organization name is NULL
 */
DROP PROCEDURE IF EXISTS read_grants_by_organization;
CREATE PROCEDURE read_grants_by_organization(
    IN  p_name  VARCHAR(256)
)
BEGIN
    IF p_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'organization name is required';
    END IF;
   
    SELECT  g.*,
            grants_status(g.start_date, g.end_date) AS derived_status
    FROM    grants AS g
    JOIN    grants_organization AS go
            ON g.grant_id = go.grant_id
    WHERE go.name = p_name
    ORDER BY g.start_date DESC;
END $$
DELIMITER ;


-- Source: read/read_grants_granted_to_faculty_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all grants granted to a specific faculty member.
 * 
 * Returns all grant records associated with the specified faculty member
 * through the grants_granted_to_faculty join table. Includes a derived
 * status field indicating whether the grant is active, expired, or upcoming.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing all columns from the grants table plus:
 *   - grant_id
 *   - description
 *   - amount
 *   - start_date
 *   - end_date
 *   - derived_status: Computed status ('Active', 'Expired', or 'Upcoming')
 * 
 * Results are ordered by start_date (oldest first).
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_grants_granted_to_faculty_by_faculty;
CREATE PROCEDURE read_grants_granted_to_faculty_by_faculty(
    IN p_faculty_id     CHAR(36)
)
BEGIN
    -- Validate that faculty_id is provided
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required';
    END IF;
    SELECT  g.*,
            grants_status(g.start_date, g.end_date) AS derived_status
    FROM    grants AS g
    JOIN    grants_granted_to_faculty AS ggf
            ON g.grant_id = ggf.grant_id
    WHERE
            ggf.faculty_id = p_faculty_id
    ORDER BY g.start_date;
END $$
DELIMITER ;


-- Source: read/read_grants_organization_by_grant.sql

DELIMITER $$

/**
 * Retrieves all organization names associated with a specific grant.
 * 
 * Returns all organization names that provided or are associated with
 * the specified grant. Grants can be associated with multiple organizations.
 * 
 * @param p_grant_id  Required UUID of the grant
 * 
 * @returns Result set containing:
 *   - name: Organization name (max 256 characters)
 *   (Multiple rows if the grant is associated with multiple organizations)
 * 
 * @throws SQLSTATE '45000' if grant_id is NULL
 */
DROP PROCEDURE IF EXISTS read_grants_organization_by_grant;
CREATE PROCEDURE read_grants_organization_by_grant(
    IN p_grant_id   CHAR(36)
)
BEGIN
    IF p_grant_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'grant_id is required';
    END IF;

    SELECT name
    FROM grants_organization
    WHERE grant_id = p_grant_id;
END $$
DELIMITER ;


-- Source: read/read_institution.sql

DELIMITER $$

/**
 * Retrieves institution records from the database.
 * 
 * Returns institution information for a specific institution or all institutions
 * in the database. Results are ordered alphabetically by institution name.
 * 
 * @param p_institution_id  Optional UUID of a specific institution to retrieve.
 *                          When provided, only that institution record is returned.
 *                          When NULL, all institutions in the database are returned.
 * 
 * @returns Result set containing all columns from the institution table:
 *   - institution_id
 *   - name
 *   - street_addr
 *   - city
 *   - state
 *   - country
 *   - zip
 *   - website_url
 *   - type
 */
CREATE PROCEDURE read_institution (
    IN p_institution_id CHAR(36)
)
BEGIN
    SELECT i.*
    FROM institution i
    WHERE (p_institution_id IS NULL OR i.institution_id = p_institution_id)
    ORDER BY i.name;
END $$

DELIMITER ;


-- Source: read/read_publication_authored_by_faculty_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all publications authored by a specific faculty member.
 * 
 * Returns all publication records where the specified faculty member
 * is listed as an author. This shows the faculty member's publication
 * history and scholarly output.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing all columns from the publication table:
 *   - publication_id
 *   - title
 *   - publisher
 *   - year
 *   - doi
 *   - abstract
 *   - citation_count
 *   (Multiple rows if the faculty member has authored multiple publications)
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_publication_authored_by_faculty_by_faculty;
CREATE PROCEDURE read_publication_authored_by_faculty_by_faculty(
    IN p_faculty_id CHAR(36)
)
BEGIN
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required';
    END IF;

    SELECT p.*
    FROM publication p
    JOIN publication_authored_by_faculty pa
        ON p.publication_id = pa.publication_id
    WHERE pa.faculty_id = p_faculty_id;
END $$
DELIMITER ;


-- Source: read/read_publication_explores_keyword_by_publication.sql

DELIMITER $$

/**
 * Retrieves all keywords associated with a specific publication.
 * 
 * Returns all keyword names that are associated with the specified
 * publication. This shows the research topics and categories for the publication.
 * 
 * @param p_publication_id  Required UUID of the publication
 * 
 * @returns Result set containing:
 *   - name: Keyword name (max 64 characters)
 *   (Multiple rows if the publication is associated with multiple keywords)
 * 
 * @throws SQLSTATE '45000' if publication_id is NULL
 */
DROP PROCEDURE IF EXISTS read_publication_explores_keyword_by_publication;
CREATE PROCEDURE read_publication_explores_keyword_by_publication(
    IN p_publication_id CHAR(36)
)
BEGIN
    IF p_publication_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'publication_id is required';
    END IF;

    SELECT name
    FROM publication_explores_keyword
    WHERE publication_id = p_publication_id;
END $$
DELIMITER ;


-- Source: read/read_session.sql

DELIMITER $$

/**
 * Retrieves all session records from the database.
 * 
 * Returns all records from the session table.
 * 
 * @returns Result set containing:
 *   - session_id: UUID of the session
 *   - faculty_id: UUID of the faculty member
 *   - token_hash: SHA-256 hash of the refresh token
 *   - created_at: When the session was created
 *   - expires_at: When the session expires
 *   - revoked: Whether the session has been revoked
 * 
 * Results are ordered by created_at descending (most recent first).
 */
DROP PROCEDURE IF EXISTS read_session;
CREATE PROCEDURE read_session()
BEGIN
    SELECT 
        session_id,
        faculty_id,
        token_hash,
        created_at,
        expires_at,
        revoked
    FROM session
    ORDER BY created_at DESC;
END $$

DELIMITER ;



-- Source: read/read_session_by_faculty.sql

DELIMITER $$

/**
 * Retrieves all active sessions for a given faculty member.
 * 
 * Returns all non-revoked, non-expired sessions for the specified faculty member.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * 
 * @returns Result set containing:
 *   - session_id: UUID of the session
 *   - faculty_id: UUID of the faculty member
 *   - created_at: When the session was created
 *   - expires_at: When the session expires
 *   - revoked: Whether the session has been revoked
 * 
 * Results are ordered by created_at descending (most recent first).
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS read_session_by_faculty;
CREATE PROCEDURE read_session_by_faculty(
    IN p_faculty_id CHAR(36)
)
BEGIN
    IF p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required';
    END IF;

    SELECT 
        session_id,
        faculty_id,
        created_at,
        expires_at,
        revoked
    FROM session
    WHERE faculty_id = p_faculty_id
        AND revoked = FALSE
        AND expires_at > UTC_TIMESTAMP()
    ORDER BY created_at DESC;
END $$

DELIMITER ;



-- Source: read/read_session_by_token_hash.sql

DELIMITER $$

/**
 * Retrieves a session record by its token hash.
 * 
 * Returns the session record for a given refresh token hash.
 * Only returns active (non-revoked, non-expired) sessions.
 * 
 * @param p_token_hash  Required SHA-256 hash of the refresh token (64 characters)
 * 
 * @returns Result set containing:
 *   - session_id: UUID of the session
 *   - faculty_id: UUID of the faculty member
 *   - created_at: When the session was created
 *   - expires_at: When the session expires
 *   - revoked: Whether the session has been revoked
 * 
 * @throws SQLSTATE '45000' if token_hash is NULL
 */
DROP PROCEDURE IF EXISTS read_session_by_token_hash;
CREATE PROCEDURE read_session_by_token_hash(
    IN p_token_hash VARCHAR(64)
)
BEGIN
    IF p_token_hash IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'token_hash is required';
    END IF;

    SELECT 
        session_id,
        faculty_id,
        created_at,
        expires_at,
        revoked
    FROM session
    WHERE token_hash = p_token_hash
        AND revoked = FALSE
        AND expires_at > UTC_TIMESTAMP();
END $$

DELIMITER ;



-- ============================================================
-- update procedures
-- ============================================================

-- Source: update/update_equipment.sql

DELIMITER $$

/**
 * Updates an existing equipment record in the database.
 * 
 * Performs a partial update on an equipment record. Only non-NULL parameters
 * will update the corresponding fields; NULL parameters leave existing values
 * unchanged. The equipment_id is required to identify which record to update.
 * 
 * @param p_equipment_id    Required UUID of the equipment record to update
 * @param p_name            Optional new equipment name (NULL to keep existing)
 * @param p_description     Optional new description (NULL to keep existing)
 * @param p_availability    Optional new availability text (NULL to keep existing)
 * @param p_institution_id  Optional new institution UUID (NULL to keep existing)
 *                          If provided, the institution must exist in the database
 * 
 * @returns Result set containing:
 *   - equipment_id: UUID of the updated equipment record
 *   - action: Status message ('updated')
 * 
 * @throws SQLSTATE '45000' if equipment_id is NULL, if equipment_id doesn't exist,
 *                    or if p_institution_id is provided but doesn't exist
 */
CREATE PROCEDURE update_equipment (
    IN p_equipment_id    CHAR(36),
    IN p_name            VARCHAR(64),
    IN p_description     VARCHAR(2048),
    IN p_availability    VARCHAR(2048),
    IN p_institution_id  CHAR(36)
)
BEGIN
    DECLARE equipment_exists INT;
    DECLARE institution_exists INT;

    IF p_equipment_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'equipment_id is required for update_equipment';
    END IF;

    SELECT COUNT(*) INTO equipment_exists
    FROM equipment
    WHERE equipment_id = p_equipment_id;

    IF equipment_exists = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'equipment_id does not exist';
    END IF;

    IF p_institution_id IS NOT NULL THEN
        SELECT COUNT(*) INTO institution_exists
        FROM institution
        WHERE institution_id = p_institution_id;

        IF institution_exists = 0 THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'institution_id does not exist';
        END IF;
    END IF;

    -- Update only the fields that are provided (non-NULL)
    -- Use conditional updates to preserve existing values when parameters are NULL
    UPDATE equipment
    SET
        name = IF(p_name IS NOT NULL, p_name, name),
        description = IF(p_description IS NOT NULL, p_description, description),
        availability = IF(p_availability IS NOT NULL, p_availability, availability),
        institution_id = IF(p_institution_id IS NOT NULL, p_institution_id, institution_id)
    WHERE equipment_id = p_equipment_id;

    SELECT p_equipment_id AS equipment_id, 'updated' AS action;
END $$

DELIMITER ;


-- Source: update/update_faculty.sql

DELIMITER $$

/**
 * Updates an existing faculty member record.
 * 
 * Performs a partial update on a faculty record. Only non-NULL parameters
 * will update the corresponding fields; NULL parameters leave existing values
 * unchanged. The faculty_id is required to identify which record to update.
 * 
 * @param p_faculty_id          Required UUID of the faculty member to update
 * @param p_first_name          Optional new first name (NULL to keep existing)
 * @param p_last_name           Optional new last name (NULL to keep existing)
 * @param p_biography           Optional new biography (NULL to keep existing)
 * @param p_orcid               Optional new ORCID (NULL to keep existing)
 * @param p_google_scholar_url  Optional new Google Scholar URL (NULL to keep existing)
 * @param p_research_gate_url   Optional new ResearchGate URL (NULL to keep existing)
 * @param p_scraped_from        Optional new scraped_from value (NULL to keep existing)
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the updated faculty member
 *   - action: Status message ('updated')
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL or empty, or if faculty_id doesn't exist
 */
CREATE PROCEDURE update_faculty (
    IN p_faculty_id          CHAR(36),
    IN p_first_name          VARCHAR(128),
    IN p_last_name           VARCHAR(128),
    IN p_biography           VARCHAR(2048),
    IN p_orcid               CHAR(19),
    IN p_google_scholar_url  VARCHAR(255),
    IN p_research_gate_url   VARCHAR(255),
    IN p_scraped_from        VARCHAR(255)
)
BEGIN
    -- Variable to check if the faculty record exists
    DECLARE existing_count INT;

    -- Validate that faculty_id is provided and not empty
    IF p_faculty_id IS NULL OR TRIM(p_faculty_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required for update_faculty';
    END IF;

    -- Verify that the faculty member exists before attempting update
    -- This prevents silent failures if an invalid ID is provided
    SELECT COUNT(*) INTO existing_count
    FROM faculty
    WHERE faculty_id = p_faculty_id;

    IF existing_count = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id does not exist';
    END IF;

    -- Perform partial update using COALESCE
    -- COALESCE returns the first non-NULL value:
    --   - If parameter is NULL, keep existing value (first_name)
    --   - If parameter has a value, use the new value (p_first_name)
    -- This allows updating only specific fields without affecting others
    UPDATE faculty
    SET
        first_name = COALESCE(p_first_name, first_name),
        last_name = COALESCE(p_last_name, last_name),
        biography = COALESCE(p_biography, biography),
        orcid = COALESCE(p_orcid, orcid),
        google_scholar_url = COALESCE(p_google_scholar_url, google_scholar_url),
        research_gate_url = COALESCE(p_research_gate_url, research_gate_url),
        scraped_from = COALESCE(p_scraped_from, scraped_from)
    WHERE faculty_id = p_faculty_id;

    -- Return confirmation of the update
    SELECT p_faculty_id AS faculty_id, 'updated' AS action;
END $$
DELIMITER ;


-- Source: update/update_faculty_department.sql

DELIMITER $$

/**
 * Updates a specific department association for a faculty member.
 * 
 * Changes an existing department name to a new value. Both the old department
 * name and new department name must be specified to uniquely identify which
 * department record to update, since faculty members can belong to multiple
 * departments.
 * 
 * @param p_faculty_id          Required UUID of the faculty member
 * @param p_old_department_name Required current department name to be changed
 * @param p_new_department_name Required new department name value
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - old_department: The previous department name
 *   - new_department: The new department name
 *   - action: Status message ('updated')
 * 
 * @throws SQLSTATE '45000' if any parameter is NULL or if no matching record exists
 */
CREATE PROCEDURE update_faculty_department (
    IN p_faculty_id CHAR(36),
    IN p_old_department_name VARCHAR(128),
    IN p_new_department_name VARCHAR(128)
)
BEGIN
    -- Validate that all required parameters are provided
    IF p_faculty_id IS NULL
       OR p_old_department_name IS NULL
       OR p_new_department_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id, old department, and new department are required.';
    END IF;

    -- Update the specific department association
    -- Both faculty_id AND old_department_name are needed in WHERE clause because
    -- a faculty member can belong to multiple departments, so we identify which one to change
    UPDATE faculty_department
    SET department_name = p_new_department_name
    WHERE faculty_id = p_faculty_id
      AND department_name = p_old_department_name;

    -- Check if any rows were actually updated
    -- ROW_COUNT() returns 0 if no matching record was found
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No matching faculty/department entry to update.';
    END IF;

    -- Return confirmation showing both old and new department names
    SELECT p_faculty_id AS faculty_id,
           p_old_department_name AS old_department,
           p_new_department_name AS new_department,
           'updated' AS action;
END $$

DELIMITER ;

-- Source: update/update_faculty_email.sql

DELIMITER $$

/**
 * Updates a specific email address for a faculty member.
 * 
 * Changes an existing email address to a new value. Both the old email
 * and new email must be specified to uniquely identify which email record
 * to update, since faculty members can have multiple email addresses.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_old_email   Required current email address to be changed
 * @param p_new_email   Required new email address value
 * 
 * @returns No result set (unlike other update procedures)
 * 
 * @throws SQLSTATE '45000' if any parameter is NULL, or if no matching record exists
 */
CREATE PROCEDURE update_faculty_email (
    IN p_faculty_id   CHAR(36),
    IN p_old_email    VARCHAR(255),
    IN p_new_email    VARCHAR(255)
)
BEGIN
    -- Validate that all required parameters are provided
    IF p_faculty_id IS NULL OR p_old_email IS NULL OR p_new_email IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id, old_email, and new_email are required for update_faculty_email';
    END IF;

    -- Update the specific email address record
    -- Both faculty_id AND old_email are needed in WHERE clause because
    -- a faculty member can have multiple email addresses, so we identify which one to change
    UPDATE faculty_email
    SET email = p_new_email
    WHERE faculty_id = p_faculty_id
      AND email = p_old_email;

    -- Check if any rows were actually updated
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No matching faculty/email entry to update';
    END IF;
END$$

DELIMITER ;

-- Source: update/update_faculty_generates_keyword.sql

DELIMITER $$

/**
 * Updates an existing faculty keyword generation record.
 * 
 * Allows updating the timestamp of a generation record. This is useful
 * if you need to correct or adjust when a generation request was recorded.
 * 
 * @param p_generation_id  Required UUID of the generation record to update
 * @param p_generated_at   Optional new timestamp (NULL to keep existing)
 * 
 * @returns Result set containing:
 *   - generation_id: UUID of the updated generation record
 *   - action: Status message ('updated')
 * 
 * @throws SQLSTATE '45000' if generation_id is NULL or doesn't exist
 */
CREATE PROCEDURE update_faculty_generates_keyword(
    IN p_generation_id CHAR(36),
    IN p_generated_at DATETIME
)
BEGIN
    -- Variable to check if the generation record exists
    DECLARE existing_count INT;

    -- Validate that generation_id is provided and not empty
    IF p_generation_id IS NULL OR TRIM(p_generation_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'generation_id is required for update_faculty_generates_keyword';
    END IF;

    -- Verify that the generation record exists before attempting update
    SELECT COUNT(*) INTO existing_count
    FROM faculty_generates_keyword
    WHERE generation_id = p_generation_id;

    IF existing_count = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'generation_id does not exist';
    END IF;

    -- Perform partial update using COALESCE
    -- If p_generated_at is NULL, keep existing value
    UPDATE faculty_generates_keyword
    SET generated_at = COALESCE(p_generated_at, generated_at)
    WHERE generation_id = p_generation_id;

    -- Return confirmation of the update
    SELECT p_generation_id AS generation_id, 'updated' AS action;
END $$

DELIMITER ;



-- Source: update/update_faculty_phone.sql

DELIMITER $$

/**
 * Updates a specific phone number for a faculty member.
 * 
 * Changes an existing phone number to a new value. Both the old phone number
 * and new phone number must be specified to uniquely identify which phone
 * record to update, since faculty members can have multiple phone numbers.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_old_phone   Required current phone number to be changed
 * @param p_new_phone   Required new phone number value
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - old_phone: The previous phone number
 *   - new_phone: The new phone number
 *   - action: Status message ('updated')
 */
CREATE PROCEDURE update_faculty_phone (
    IN p_faculty_id   CHAR(36),
    IN p_old_phone    VARCHAR(32),
    IN p_new_phone    VARCHAR(32)
)
BEGIN
    -- Validate that all required parameters are provided
    IF p_faculty_id IS NULL OR p_old_phone IS NULL OR p_new_phone IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id, old_phone, and new_phone are required for update_faculty_phone';
    END IF;

    -- Update the specific phone number record
    -- Both faculty_id AND old_phone are needed in WHERE clause because
    -- a faculty member can have multiple phone numbers, so we identify which one to change
    UPDATE faculty_phone
    SET phone_num = p_new_phone
    WHERE faculty_id = p_faculty_id
      AND phone_num  = p_old_phone;

    -- Check if any rows were actually updated
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No matching faculty/phone entry to update';
    END IF;

    -- Return confirmation showing both old and new phone numbers
    SELECT p_faculty_id AS faculty_id,
           p_old_phone AS old_phone,
           p_new_phone AS new_phone,
           'updated' AS action;
END$$

DELIMITER ;

-- Source: update/update_faculty_title.sql

DELIMITER $$

/**
 * Updates a specific title for a faculty member.
 * 
 * Changes an existing title to a new value. Both the old title and new title
 * must be specified to uniquely identify which title record to update, since
 * faculty members can have multiple titles.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_old_title   Required current title value to be changed
 * @param p_new_title   Required new title value
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - old_title: The previous title value
 *   - new_title: The new title value
 *   - action: Status message ('updated')
 */
CREATE PROCEDURE update_faculty_title (
    IN p_faculty_id   CHAR(36),
    IN p_old_title    VARCHAR(255),
    IN p_new_title    VARCHAR(255)
)
BEGIN
    -- Validate that all required parameters are provided
    IF p_faculty_id IS NULL OR p_old_title IS NULL OR p_new_title IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id, old_title, and new_title are required for update_faculty_title';
    END IF;

    -- Update the specific title record
    -- Both faculty_id AND old_title are needed in WHERE clause because
    -- a faculty member can have multiple titles, so we need to identify which one to change
    UPDATE faculty_title
    SET title = p_new_title
    WHERE faculty_id = p_faculty_id
      AND title      = p_old_title;

    -- Check if any rows were actually updated
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No matching faculty/title entry to update';
    END IF;

    -- Return confirmation showing both old and new values
    SELECT p_faculty_id AS faculty_id,
           p_old_title AS old_title,
           p_new_title AS new_title,
           'updated' AS action;
END$$

DELIMITER ;

-- Source: update/update_faculty_works_at_institution.sql

DELIMITER $$

/**
 * Updates an existing faculty-institution relationship record in the database.
 * 
 * Updates the start_date and end_date for a faculty-institution relationship.
 * The record is identified using only faculty_id and institution_id (the composite
 * primary key). Both dates are updated directly using a simple UPDATE statement.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_institution_id  Required UUID of the institution
 * @param p_start_date      Required new start date for the relationship
 * @param p_end_date        Optional new end date for the relationship (NULL allowed)
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - institution_id: UUID of the institution
 *   - start_date: The new start date
 *   - end_date: The new end date
 *   - action: Status message ('updated')
 * 
 * @throws SQLSTATE '45000' if faculty_id, institution_id, or start_date is NULL
 * @throws SQLSTATE '45000' if no relationship exists for the given faculty_id and institution_id
 */
CREATE PROCEDURE update_faculty_works_at_institution (
    IN p_faculty_id      CHAR(36),
    IN p_institution_id  CHAR(36),
    IN p_start_date      DATE,
    IN p_end_date        DATE
)
BEGIN
    DECLARE rel_exists INT;

    -- Validate required parameters
    IF p_faculty_id IS NULL OR p_institution_id IS NULL OR p_start_date IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id, institution_id, and start_date are required for update_faculty_works_at_institution';
    END IF;

    -- Check if the relationship exists
    SELECT COUNT(*) INTO rel_exists
    FROM faculty_works_at_institution
    WHERE faculty_id = p_faculty_id
      AND institution_id = p_institution_id;

    IF rel_exists = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_works_at_institution entry not found';
    END IF;

    -- Update the start_date and end_date directly
    -- Since start_date is no longer part of the primary key, we can do a simple UPDATE
    UPDATE faculty_works_at_institution
    SET
        start_date = p_start_date,
        end_date = p_end_date
    WHERE faculty_id = p_faculty_id
      AND institution_id = p_institution_id;

    -- Return the updated values
    SELECT p_faculty_id AS faculty_id,
           p_institution_id AS institution_id,
           p_start_date AS start_date,
           p_end_date AS end_date,
           'updated' AS action;
END $$

DELIMITER ;


-- Source: update/update_grants.sql

DELIMITER $$

/**
 * Updates an existing grant record in the database.
 * 
 * Updates all fields of a grant record. All parameters except description
 * and end_date are required. This performs a full update, replacing all
 * values rather than a partial update.
 * 
 * @param p_grant_id      Required UUID of the grant record to update
 * @param p_description   Optional new description (NULL allowed)
 * @param p_amount        Required new grant amount (DECIMAL with 10 digits, 2 decimal places)
 * @param p_start_date    Required new start date of the grant period
 * @param p_end_date      Optional new end date of the grant period (NULL allowed)
 * 
 * @returns No result set. Use read procedures to verify the update.
 * 
 * @throws SQLSTATE '45000' if grant_id, amount, or start_date is NULL
 * @throws SQLSTATE '45000' if grant_id doesn't exist
 */
DROP PROCEDURE IF EXISTS update_grants;
CREATE PROCEDURE update_grants(
    IN p_grant_id       CHAR(36),
    IN p_description    VARCHAR(2048),
    IN p_amount         DECIMAL(10,2),
    IN p_start_date     DATE,
    IN p_end_date       DATE
)
BEGIN
    IF p_grant_id IS NULL OR p_amount IS NULL OR p_start_date IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'grant_id, amount, and start_date are required for update_grants';
    END IF;

    UPDATE grants
    SET 
        description = p_description, 
        amount = p_amount, 
        start_date = p_start_date, 
        end_date = p_end_date
    WHERE grant_id = p_grant_id;
END $$
DELIMITER ;


-- Source: update/update_grants_organization.sql

DELIMITER $$

/**
 * Updates or creates an organization association for a grant.
 * 
 * Inserts a new grants_organization record, or updates an existing one if
 * a record with the same grant_id already exists. This uses MySQL's
 * ON DUPLICATE KEY UPDATE to handle both insert and update in one operation.
 * 
 * @param p_grant_id  Required UUID of the grant
 * @param p_name      Required organization name (max 255 characters)
 * 
 * @returns No result set. Use read procedures to verify the update/insert.
 * 
 * @throws SQLSTATE '23000' if grant_id doesn't exist (foreign key constraint)
 */
DROP PROCEDURE IF EXISTS update_grants_organization;
CREATE PROCEDURE update_grants_organization(
    IN  p_grant_id  CHAR(36),
    IN  p_name      VARCHAR(255)
)
BEGIN
    IF p_grant_id IS NULL OR p_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'grant_id and name are required for update_grants_organization';
    END IF;

    INSERT INTO grants_organization (grant_id, name)
    VALUES  (p_grant_id, p_name)
    ON DUPLICATE KEY UPDATE
        name = VALUES(name);
END $$
DELIMITER ;


-- Source: update/update_institution.sql

DELIMITER $$

/**
 * Updates an existing institution record in the database.
 * 
 * Performs a partial update on an institution record. Only non-NULL parameters
 * will update the corresponding fields; NULL parameters leave existing values
 * unchanged. The institution_id is required to identify which record to update.
 * 
 * @param p_institution_id  Required UUID of the institution record to update
 * @param p_name            Optional new institution name (NULL to keep existing)
 * @param p_street_addr     Optional new street address (NULL to keep existing)
 * @param p_city            Optional new city (NULL to keep existing)
 * @param p_state           Optional new state/province (NULL to keep existing)
 * @param p_country         Optional new country (NULL to keep existing)
 * @param p_zip             Optional new postal code (NULL to keep existing)
 * @param p_website_url     Optional new website URL (NULL to keep existing)
 * @param p_type            Optional new institution type (NULL to keep existing)
 * 
 * @returns Result set containing:
 *   - institution_id: UUID of the updated institution record
 *   - action: Status message ('updated')
 * 
 * @throws SQLSTATE '45000' if institution_id is NULL or if institution_id doesn't exist
 */
CREATE PROCEDURE update_institution (
    IN p_institution_id  CHAR(36),
    IN p_name            VARCHAR(256),
    IN p_street_addr     VARCHAR(255),
    IN p_city            VARCHAR(255),
    IN p_state           VARCHAR(255),
    IN p_country         VARCHAR(255),
    IN p_zip             VARCHAR(16),
    IN p_website_url     VARCHAR(255),
    IN p_type            VARCHAR(64)
)
BEGIN
    DECLARE inst_exists INT;

    IF p_institution_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'institution_id is required for update_institution';
    END IF;

    SELECT COUNT(*) INTO inst_exists
    FROM institution
    WHERE institution_id = p_institution_id;

    IF inst_exists = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'institution_id does not exist';
    END IF;

    -- Update only the fields that are provided (non-NULL)
    -- Use conditional updates to preserve existing values when parameters are NULL
    UPDATE institution
    SET
        name = IF(p_name IS NOT NULL, p_name, name),
        street_addr = IF(p_street_addr IS NOT NULL, p_street_addr, street_addr),
        city = IF(p_city IS NOT NULL, p_city, city),
        state = IF(p_state IS NOT NULL, p_state, state),
        country = IF(p_country IS NOT NULL, p_country, country),
        zip = IF(p_zip IS NOT NULL, p_zip, zip),
        website_url = IF(p_website_url IS NOT NULL, p_website_url, website_url),
        type = IF(p_type IS NOT NULL, p_type, type)
    WHERE institution_id = p_institution_id;

    SELECT p_institution_id AS institution_id, 'updated' AS action;
END $$

DELIMITER ;


-- Source: update/update_keyword.sql

DELIMITER $$

/**
 * Updates a keyword name in the database.
 * 
 * Changes the name of an existing keyword from the old name to a new name.
 * Since keyword name is the primary key, this effectively renames the keyword.
 * All associations with this keyword (faculty, publications, grants) will
 * automatically update due to foreign key constraints.
 * 
 * @param p_old_name  Required current keyword name to be changed
 * @param p_new_name  Required new keyword name (max 64 characters)
 * 
 * @returns No result set. Use read procedures to verify the update.
 * 
 * @throws SQLSTATE '45000' if old_name or new_name is NULL
 * @throws SQLSTATE '45000' if old_name doesn't exist
 * @throws SQLSTATE '23000' if new_name already exists (unique constraint)
 */
CREATE PROCEDURE update_keyword(
    IN p_old_name VARCHAR(64),
    IN p_new_name VARCHAR(64)
)
BEGIN
    IF p_old_name IS NULL OR p_new_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'old_name and new_name are required for update_keyword';
    END IF;

    UPDATE keyword
    SET name = p_new_name
    WHERE name = p_old_name;

    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Keyword with old_name does not exist';
    END IF;
END $$
DELIMITER ;


-- Source: update/update_password.sql

DELIMITER $$

/**
 * Updates a faculty member's password.
 * 
 * Changes the password for a faculty member's credentials. The old password
 * must be provided and verified before the new password is set. The new
 * password is hashed using the existing salt for security.
 * 
 * @param p_faculty_id    Required UUID of the faculty member
 * @param p_old_password  Required current password (plain text, for verification)
 * @param p_new_password  Required new password (plain text, will be hashed)
 * 
 * @returns No result set. Use validate_login to test the new credentials.
 * 
 * @throws SQLSTATE '45000' if any parameter is NULL
 * @throws SQLSTATE '45000' if faculty_id doesn't exist or has no credentials
 * @throws SQLSTATE '45000' if old_password is incorrect
 */
DROP PROCEDURE IF EXISTS update_password;
CREATE PROCEDURE update_password(
    IN p_faculty_id     CHAR(36),
    IN p_old_password   VARCHAR(255),
    IN p_new_password   VARCHAR(255)
)
BEGIN
    DECLARE v_salt              VARCHAR(255);
    DECLARE v_expected_hash     VARCHAR(255);
    DECLARE v_old_hash          CHAR(64);

    IF p_faculty_id IS NULL OR p_old_password IS NULL OR p_new_password IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id, old_password, and new_password are required';
    END IF;

    -- RETRIEVE CURRENT PW AND SALT
    SELECT  password_salt, password_hash
    INTO    v_salt, v_expected_hash
    FROM    credentials
    WHERE   faculty_id = p_faculty_id;

    IF v_salt IS NULL OR v_expected_hash IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Credentials not found for this faculty_id';
    END IF;

    -- VERIFY OLD PW TO INPUT
    SET v_old_hash = hash_password(p_old_password, v_salt);
    IF v_old_hash <> v_expected_hash THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Old password is incorrect';
    END IF;

    -- UPDATE PASSWORD
    UPDATE credentials
    SET password_hash = hash_password(p_new_password, v_salt)
    WHERE faculty_id = p_faculty_id;
END $$
DELIMITER ;


-- Source: update/update_publication.sql

DELIMITER $$

/**
 * Updates an existing publication record in the database.
 * 
 * Performs a partial update on a publication record. Only non-NULL parameters
 * will update the corresponding fields; NULL parameters leave existing values
 * unchanged. The publication_id is required to identify which record to update.
 * 
 * @param p_publication_id  Required UUID of the publication record to update
 * @param p_title            Optional new publication title (NULL to keep existing)
 * @param p_publisher        Optional new publisher name (NULL to keep existing)
 * @param p_year             Optional new publication year (NULL to keep existing)
 * @param p_doi              Optional new Digital Object Identifier (NULL to keep existing)
 * @param p_abstract          Optional new abstract text (NULL to keep existing)
 * @param p_citation_count   Optional new citation count (NULL to keep existing)
 * 
 * @returns No result set. Use read procedures to verify the update.
 * 
 * @throws SQLSTATE '45000' if publication_id is NULL
 * @throws SQLSTATE '45000' if publication_id doesn't exist
 */
CREATE PROCEDURE update_publication(
    IN p_publication_id CHAR(36),
    IN p_title VARCHAR(64),
    IN p_publisher VARCHAR(255),
    IN p_year INT,
    IN p_doi VARCHAR(64),
    IN p_abstract TEXT,
    IN p_citation_count INT
)
BEGIN
    IF p_publication_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'publication_id is required for update_publication';
    END IF;

    -- Title
    IF p_title IS NOT NULL THEN
        UPDATE publication
        SET title = p_title
        WHERE publication_id = p_publication_id;
    END IF;

    -- Publisher
    IF p_publisher IS NOT NULL THEN
        UPDATE publication
        SET publisher = p_publisher
        WHERE publication_id = p_publication_id;
    END IF;

    -- Year
    IF p_year IS NOT NULL THEN
        UPDATE publication
        SET year = p_year
        WHERE publication_id = p_publication_id;
    END IF;

    -- DOI
    IF p_doi IS NOT NULL THEN
        UPDATE publication
        SET doi = p_doi
        WHERE publication_id = p_publication_id;
    END IF;

    -- Abstract
    IF p_abstract IS NOT NULL THEN
        UPDATE publication
        SET abstract = p_abstract
        WHERE publication_id = p_publication_id;
    END IF;

    -- Citation Count
    IF p_citation_count IS NOT NULL THEN
        UPDATE publication
        SET citation_count = p_citation_count
        WHERE publication_id = p_publication_id;
    END IF;
END $$
DELIMITER ;


-- Source: update/update_session.sql

DELIMITER $$

/**
 * Updates session records based on identifier and optional fields.
 * 
 * This unified procedure allows updating any session field(s) by identifying
 * the session(s) using one of: session_id, token_hash, or faculty_id.
 * 
 * At least one identifier must be provided. If multiple identifiers are provided,
 * they are combined with AND logic (most specific match).
 * 
 * @param p_session_id    Optional UUID of the specific session to update
 * @param p_token_hash    Optional SHA-256 hash of the refresh token (64 characters)
 * @param p_faculty_id    Optional UUID of the faculty member (updates all their sessions)
 * @param p_revoked       Optional boolean value for the revoked flag
 * @param p_expires_at    Optional datetime value for the expiration time
 * 
 * @returns No result set. Use read procedures to verify the update.
 * 
 * @throws SQLSTATE '45000' if no identifier is provided
 * @throws SQLSTATE '45000' if no fields to update are provided
 */
DROP PROCEDURE IF EXISTS update_session;
CREATE PROCEDURE update_session(
    IN p_session_id CHAR(36),
    IN p_token_hash VARCHAR(64),
    IN p_faculty_id CHAR(36),
    IN p_revoked BOOLEAN,
    IN p_expires_at DATETIME
)
BEGIN
    -- Validate that at least one identifier is provided
    IF p_session_id IS NULL AND p_token_hash IS NULL AND p_faculty_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'At least one identifier (session_id, token_hash, or faculty_id) is required';
    END IF;

    -- Validate that at least one field to update is provided
    IF p_revoked IS NULL AND p_expires_at IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'At least one field to update (revoked or expires_at) is required';
    END IF;

    -- Update session(s) based on provided identifiers and fields
    UPDATE session
    SET 
        revoked = IF(p_revoked IS NOT NULL, p_revoked, revoked),
        expires_at = IF(p_expires_at IS NOT NULL, p_expires_at, expires_at)
    WHERE 
        (p_session_id IS NULL OR session_id = p_session_id)
        AND (p_token_hash IS NULL OR token_hash = p_token_hash)
        AND (p_faculty_id IS NULL OR faculty_id = p_faculty_id);
END $$

DELIMITER ;


-- ============================================================
-- delete procedures
-- ============================================================

-- Source: delete/delete_equipment.sql

DELIMITER $$

/**
 * Deletes an equipment record from the database.
 * 
 * Removes the equipment record identified by the provided equipment_id.
 * Note: This operation may fail if there are foreign key constraints from
 * related tables depending on the database schema configuration.
 * 
 * @param p_equipment_id  Required UUID of the equipment record to delete.
 * 
 * @returns Result set containing:
 *   - equipment_id: UUID of the deleted equipment record
 *   - action: Status message ('deleted')
 * 
 * @throws SQLSTATE '45000' if equipment_id is NULL
 */
CREATE PROCEDURE delete_equipment (
    IN p_equipment_id CHAR(36)
)
BEGIN
    IF p_equipment_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'equipment_id is required for delete_equipment';
    END IF;

    DELETE FROM equipment
    WHERE equipment_id = p_equipment_id;

    SELECT p_equipment_id AS equipment_id, 'deleted' AS action;
END $$

DELIMITER ;


-- Source: delete/delete_faculty.sql

DELIMITER $$

/**
 * Deletes a faculty member record from the database.
 * 
 * Removes the faculty record identified by the provided faculty_id.
 * Note: This may fail if there are foreign key constraints from related tables
 * (e.g., publications, departments, emails, etc.) depending on database schema.
 * 
 * @param p_faculty_id  Required UUID of the faculty member to delete
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the deleted faculty member
 *   - action: Status message ('deleted')
 */
CREATE PROCEDURE delete_faculty (
    IN p_faculty_id CHAR(36)
)
BEGIN
    -- Delete the faculty record matching the provided ID
    DELETE FROM faculty
    WHERE faculty_id = p_faculty_id;

    -- Return confirmation with the deleted ID and status message
    SELECT p_faculty_id AS faculty_id, 'deleted' AS action;
END$$

DELIMITER ;

-- Source: delete/delete_faculty_department.sql

DELIMITER $$

/**
 * Removes a specific department association from a faculty member.
 * 
 * Deletes a department association for the specified faculty member. Both
 * faculty_id and department_name must be provided to uniquely identify which
 * department record to remove, since faculty members can belong to multiple
 * departments.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_department_name Required department name to remove
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - department_name: The department name that was deleted
 *   - action: Status message ('deleted')
 * 
 * @throws SQLSTATE '45000' if faculty_id or department_name is NULL, or if no matching record exists
 */
CREATE PROCEDURE delete_faculty_department (
    IN p_faculty_id CHAR(36),
    IN p_department_name VARCHAR(128)
)
BEGIN
    -- Validate that both required parameters are provided
    IF p_faculty_id IS NULL OR p_department_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and department_name are required.';
    END IF;

    -- Delete the specific department association
    -- Both faculty_id AND department_name are required in WHERE clause to uniquely
    -- identify which department to remove (since faculty can belong to multiple departments)
    DELETE FROM faculty_department
    WHERE faculty_id = p_faculty_id
      AND department_name = p_department_name;

    -- Check if any rows were actually deleted
    -- ROW_COUNT() returns 0 if no matching record was found
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No matching faculty/department entry to delete.';
    END IF;

    -- Return confirmation of what was deleted
    SELECT p_faculty_id AS faculty_id,
           p_department_name AS department_name,
           'deleted' AS action;
END $$

DELIMITER ;

-- Source: delete/delete_faculty_email.sql

DELIMITER $$

/**
 * Removes a specific email address from a faculty member.
 * 
 * Deletes an email association for the specified faculty member. Both
 * faculty_id and email must be provided to uniquely identify which email
 * record to remove, since faculty members can have multiple email addresses.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_email       Required email address to remove
 * 
 * @returns No result set (unlike other delete procedures)
 */
CREATE PROCEDURE delete_faculty_email (
    IN p_faculty_id CHAR(36),
    IN p_email      VARCHAR(255)
)
BEGIN
    -- Delete the specific email address association
    -- Both faculty_id AND email are required in WHERE clause to uniquely
    -- identify which email to remove (since faculty can have multiple emails)
    -- Note: This procedure does not return a result set (unlike other delete procedures)
    DELETE FROM faculty_email
    WHERE faculty_id = p_faculty_id
      AND email = p_email;
END$$

DELIMITER ;

-- Source: delete/delete_faculty_follows_faculty.sql

DELIMITER $$

/**
 * Removes a follow relationship between two faculty members.
 * 
 * Deletes a specific follow relationship where one faculty member
 * (follower) follows another faculty member (followee). Both IDs
 * must be provided to uniquely identify which relationship to remove.
 * 
 * @param p_follower_id  Required UUID of the faculty member who is following
 * @param p_followee_id  Required UUID of the faculty member being followed
 * 
 * @returns Result set containing:
 *   - follower_id: UUID of the faculty member who was following
 *   - followee_id: UUID of the faculty member who was being followed
 *   - action: Status message ('deleted')
 * 
 * @throws SQLSTATE '45000' if follower_id or followee_id is NULL, or if no matching relationship exists
 */
CREATE PROCEDURE delete_faculty_follows_faculty (
    IN p_follower_id CHAR(36),
    IN p_followee_id CHAR(36)
)
BEGIN
    -- Validate that both required parameters are provided
    IF p_follower_id IS NULL OR p_followee_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'follower_id and followee_id are required.';
    END IF;

    -- Delete the specific follow relationship
    -- Both follower_id AND followee_id are required in WHERE clause to uniquely
    -- identify which relationship to remove
    DELETE FROM faculty_follows_faculty
    WHERE follower_id = p_follower_id
      AND followee_id = p_followee_id;

    -- Check if any rows were actually deleted
    -- ROW_COUNT() returns 0 if no matching record was found
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No matching follow relationship to delete.';
    END IF;

    -- Return confirmation of what was deleted
    SELECT p_follower_id AS follower_id,
           p_followee_id AS followee_id,
           'deleted' AS action;
END $$

DELIMITER ;


-- Source: delete/delete_faculty_generates_keyword.sql

DELIMITER $$

/**
 * Deletes a faculty keyword generation record from the database.
 * 
 * Removes a specific generation record. This can be used to clean up old records
 * or remove specific entries for administrative purposes.
 * 
 * @param p_generation_id  Required UUID of the generation record to delete
 * 
 * @returns No result set. Use read procedures to verify the deletion.
 * 
 * @throws SQLSTATE '45000' if generation_id is NULL or empty
 */
CREATE PROCEDURE delete_faculty_generates_keyword(
    IN p_generation_id CHAR(36)
)
BEGIN
    IF p_generation_id IS NULL OR TRIM(p_generation_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'generation_id is required for delete_faculty_generates_keyword';
    END IF;

    DELETE FROM faculty_generates_keyword
    WHERE generation_id = p_generation_id;
END $$

DELIMITER ;



-- Source: delete/delete_faculty_phone.sql

DELIMITER $$

/**
 * Removes a specific phone number from a faculty member.
 * 
 * Deletes a phone number association for the specified faculty member.
 * Both faculty_id and phone_num must be provided to uniquely identify
 * which phone record to remove, since faculty members can have multiple
 * phone numbers.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_phone_num   Required phone number to remove
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - phone_num: The phone number that was deleted
 *   - action: Status message ('deleted')
 */
CREATE PROCEDURE delete_faculty_phone (
    IN p_faculty_id CHAR(36),
    IN p_phone_num  VARCHAR(32)
)
BEGIN
    -- Delete the specific phone number association
    -- Both faculty_id AND phone_num are required in WHERE clause to uniquely
    -- identify which phone number to remove (since faculty can have multiple phones)
    DELETE FROM faculty_phone
    WHERE faculty_id = p_faculty_id
      AND phone_num  = p_phone_num;

    -- Return confirmation of what was deleted
    SELECT p_faculty_id AS faculty_id,
           p_phone_num AS phone_num,
           'deleted' AS action;
END$$

DELIMITER ;

-- Source: delete/delete_faculty_researches_keyword.sql

DELIMITER $$

/**
 * Deletes a faculty-keyword research association from the database.
 * 
 * Removes a specific faculty_researches_keyword relationship, disassociating
 * a keyword from a faculty member's research interests. This does not delete
 * the faculty member or the keyword, only the association between them.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_name        Required keyword name to disassociate
 * 
 * @returns No result set. Use read procedures to verify the deletion.
 * 
 * @throws SQLSTATE '45000' if faculty_id or keyword name is NULL
 */
CREATE PROCEDURE delete_faculty_researches_keyword(
    IN p_faculty_id CHAR(36),
    IN p_name VARCHAR(64)
)
BEGIN
    IF p_faculty_id IS NULL OR p_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and keyword name are required for delete_faculty_researches_keyword';
    END IF;

    DELETE FROM faculty_researches_keyword
    WHERE faculty_id = p_faculty_id
      AND name = p_name;
END $$
DELIMITER ;


-- Source: delete/delete_faculty_title.sql

DELIMITER $$

/**
 * Removes a specific title from a faculty member.
 * 
 * Deletes a title association for the specified faculty member. Both
 * faculty_id and title must be provided to uniquely identify which
 * title record to remove, since faculty members can have multiple titles.
 * 
 * @param p_faculty_id  Required UUID of the faculty member
 * @param p_title       Required title to remove
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - title: The title that was deleted
 *   - action: Status message ('deleted')
 */
CREATE PROCEDURE delete_faculty_title (
    IN p_faculty_id CHAR(36),
    IN p_title      VARCHAR(255)
)
BEGIN
    -- Delete the specific title association
    -- Both faculty_id AND title are required in WHERE clause to uniquely
    -- identify which title to remove (since faculty can have multiple titles)
    DELETE FROM faculty_title
    WHERE faculty_id = p_faculty_id
      AND title = p_title;

    -- Return confirmation of what was deleted
    SELECT p_faculty_id AS faculty_id,
           p_title AS title,
           'deleted' AS action;
END$$

DELIMITER ;

-- Source: delete/delete_faculty_works_at_institution.sql

DELIMITER $$

/**
 * Deletes a faculty-institution relationship record from the database.
 * 
 * Removes a specific faculty_works_at_institution relationship identified by
 * the composite primary key (faculty_id, institution_id, start_date). This
 * allows removing a specific employment period for a faculty member at an
 * institution, even if they have multiple employment periods at the same
 * institution.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_institution_id  Required UUID of the institution
 * @param p_start_date      Required start date of the employment relationship
 *                          (part of the composite primary key)
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - institution_id: UUID of the institution
 *   - start_date: Start date of the deleted relationship
 *   - action: Status message ('deleted')
 * 
 * @throws SQLSTATE '45000' if any required parameter is NULL
 */
CREATE PROCEDURE delete_faculty_works_at_institution (
    IN p_faculty_id      CHAR(36),
    IN p_institution_id  CHAR(36),
    IN p_start_date      DATE
)
BEGIN
    IF p_faculty_id IS NULL OR p_institution_id IS NULL OR p_start_date IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id, institution_id, and start_date are required for delete_faculty_works_at_institution';
    END IF;

    DELETE FROM faculty_works_at_institution
    WHERE faculty_id = p_faculty_id
      AND institution_id = p_institution_id
      AND start_date = p_start_date;

    SELECT p_faculty_id AS faculty_id,
           p_institution_id AS institution_id,
           p_start_date AS start_date,
           'deleted' AS action;
END $$

DELIMITER ;


-- Source: delete/delete_grants.sql

DELIMITER $$

/**
 * Deletes a grant record from the database.
 * 
 * Removes the grant record identified by the provided grant_id. This operation
 * may cascade delete related records (e.g., grants_granted_to_faculty,
 * grants_for_keyword, grants_organization) depending on foreign key
 * constraints configured in the database schema.
 * 
 * @param p_grant_id  Required UUID of the grant record to delete
 * 
 * @returns No result set. Use read procedures to verify the deletion.
 * 
 * @throws SQLSTATE '45000' if grant_id is NULL
 */
CREATE PROCEDURE delete_grants(
    IN p_grant_id CHAR(36)
)
BEGIN
    IF p_grant_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'grant_id is required for delete_grants';
    END IF;

    DELETE FROM grants
    WHERE grant_id = p_grant_id;
END $$
DELIMITER ;


-- Source: delete/delete_institution.sql

DELIMITER $$

/**
 * Deletes an institution record from the database.
 * 
 * Removes the institution record identified by the provided institution_id.
 * Note: This operation may cascade delete related records (e.g., equipment,
 * faculty_works_at_institution relationships) depending on foreign key
 * constraints configured in the database schema.
 * 
 * @param p_institution_id  Required UUID of the institution record to delete.
 * 
 * @returns Result set containing:
 *   - institution_id: UUID of the deleted institution record
 *   - action: Status message ('deleted')
 * 
 * @throws SQLSTATE '45000' if institution_id is NULL
 */
CREATE PROCEDURE delete_institution (
    IN p_institution_id CHAR(36)
)
BEGIN
    IF p_institution_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'institution_id is required for delete_institution';
    END IF;

    DELETE FROM institution
    WHERE institution_id = p_institution_id;

    SELECT p_institution_id AS institution_id, 'deleted' AS action;
END $$

DELIMITER ;


-- Source: delete/delete_keyword.sql

DELIMITER $$

/**
 * Deletes a keyword record from the database.
 * 
 * Removes the keyword record identified by the provided name. This operation
 * may cascade delete related records (e.g., faculty_researches_keyword,
 * publication_explores_keyword, grants_for_keyword) depending on foreign key
 * constraints configured in the database schema.
 * 
 * @param p_name  Required keyword name to delete
 * 
 * @returns No result set. Use read procedures to verify the deletion.
 * 
 * @throws SQLSTATE '45000' if keyword name is NULL
 */
CREATE PROCEDURE delete_keyword(
    IN p_name VARCHAR(64)
)
BEGIN
    IF p_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'keyword name is required for delete_keyword';
    END IF;

    DELETE FROM keyword
    WHERE name = p_name;
END $$
DELIMITER ;


-- Source: delete/delete_publication.sql

DELIMITER $$

/**
 * Deletes a publication record from the database.
 * 
 * Removes the publication record identified by the provided publication_id.
 * This operation may cascade delete related records (e.g.,
 * publication_authored_by_faculty, publication_explores_keyword) depending
 * on foreign key constraints configured in the database schema.
 * 
 * @param p_id  Required UUID of the publication record to delete
 * 
 * @returns No result set. Use read procedures to verify the deletion.
 * 
 * @throws SQLSTATE '45000' if publication_id is NULL
 */
CREATE PROCEDURE delete_author_publication(
    IN p_id CHAR(36)
)
BEGIN
    IF p_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'publication_id is required for delete_author_publication';
    END IF;

    DELETE FROM publication
    WHERE publication_id = p_id;
END $$

DELIMITER ;


-- Source: delete/delete_publication_authored_by_faculty.sql

DELIMITER $$

/**
 * Deletes a publication-author association from the database.
 * 
 * Removes a specific publication_authored_by_faculty relationship, disassociating
 * a faculty member from a publication. This does not delete the faculty member
 * or the publication, only the authorship relationship between them.
 * 
 * @param p_faculty_id      Required UUID of the faculty member
 * @param p_publication_id  Required UUID of the publication
 * 
 * @returns No result set. Use read procedures to verify the deletion.
 * 
 * @throws SQLSTATE '45000' if faculty_id or publication_id is NULL
 */
CREATE PROCEDURE delete_publication_authored_by_faculty(
    IN p_faculty_id CHAR(36),
    IN p_publication_id CHAR(36)
)
BEGIN
    IF p_faculty_id IS NULL OR p_publication_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and publication_id are required for delete_publication_authored_by_faculty';
    END IF;

    DELETE FROM publication_authored_by_faculty
    WHERE faculty_id = p_faculty_id AND publication_id = p_publication_id;
END $$
DELIMITER ;


-- Source: delete/delete_publication_explores_keyword.sql

DELIMITER $$

/**
 * Deletes a publication-keyword association from the database.
 * 
 * Removes a specific publication_explores_keyword relationship, disassociating
 * a keyword from a publication. This does not delete the publication or the
 * keyword, only the association between them.
 * 
 * @param p_publication_id  Required UUID of the publication
 * @param p_name            Required keyword name to disassociate
 * 
 * @returns No result set. Use read procedures to verify the deletion.
 * 
 * @throws SQLSTATE '45000' if publication_id or keyword name is NULL
 */
CREATE PROCEDURE delete_publication_explores_keyword(
    IN p_publication_id CHAR(36),
    IN p_name VARCHAR(64)
)
BEGIN
    IF p_publication_id IS NULL OR p_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'publication_id and keyword name are required for delete_publication_explores_keyword';
    END IF;

    DELETE FROM publication_explores_keyword
    WHERE publication_id = p_publication_id
      AND name = p_name;
END $$
DELIMITER ;


-- ============================================================
-- workflow procedures
-- ============================================================

-- Source: workflow/add_keyword_for_faculty.sql

DELIMITER $$

/**
 * Adds a new keyword and associates it with a faculty member.
 * 
 * This workflow procedure combines two operations:
 * 1. Creates a new keyword record
 * 2. Links the keyword to the specified faculty member via the join table
 * 
 * This is a convenience procedure that handles the complete workflow of
 * adding a keyword for a faculty member in a single call.
 * 
 * @param p_faculty_id    Required UUID of the faculty member
 * @param p_name          Required keyword name (max 64 characters)
 * 
 * @returns Result set containing:
 *   - keyword_id: UUID of the newly created keyword
 *   - faculty_id: UUID of the associated faculty member
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if faculty_id is NULL
 */
DROP PROCEDURE IF EXISTS add_keyword_for_faculty;
CREATE PROCEDURE add_keyword_for_faculty(
    IN p_faculty_id CHAR(36),
    IN p_name VARCHAR(64)
)
BEGIN
    -- Validate input: faculty_id must be provided
    IF p_faculty_id IS NULL OR p_name IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and keyword name are required.';
    END IF;

    -- Step 1: Create the keyword record
    CALL create_keyword(p_name);

    -- Step 2: Link the keyword to the faculty member
    CALL create_faculty_researches_keyword(p_faculty_id, p_name);

    -- Step 3: Return confirmation with both IDs for reference
    SELECT p_faculty_id AS faculty_id,
           p_name AS keyword_id,
           'inserted' AS action;
END $$
DELIMITER ;

-- Source: workflow/add_publication_for_faculty.sql

DELIMITER $$

/**
 * Adds a new publication and associates it with a faculty member.
 * 
 * This workflow procedure combines two operations:
 * 1. Creates a new publication record
 * 2. Links the publication to the specified faculty member via the join table
 * 
 * This is a convenience procedure that handles the complete workflow of
 * adding a publication for a faculty member in a single call.
 * 
 * @param p_faculty_id     Required UUID of the faculty member
 * @param p_publication_id Required UUID of the publication
 * @param p_title          Publication title
 * @param p_publisher      Publisher name
 * @param p_year           Publication year
 * @param p_doi            Digital Object Identifier (DOI)
 * @param p_abstract       Publication abstract text
 * @param p_citation_count Citation count
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the associated faculty member
 *   - publication_id: UUID of the newly created publication
 *   - action: Status message ('inserted')
 * 
 * @throws SQLSTATE '45000' if faculty_id or publication_id is NULL
 */
CREATE PROCEDURE add_publication_for_faculty (
    IN p_faculty_id CHAR(36),
    IN p_publication_id CHAR(36),
    IN p_title VARCHAR(64),
    IN p_publisher VARCHAR(255),
    IN p_year INT,
    IN p_doi VARCHAR(64),
    IN p_abstract TEXT,
    IN p_citation_count INT
)
BEGIN
    -- Validate input: faculty_id and publication_id must be provided
    IF p_faculty_id IS NULL OR p_publication_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id and publication_id are required.';
    END IF;

    -- Step 1: Create the publication record
    CALL create_publication(
        p_publication_id,
        p_title,
        p_publisher,
        p_year,
        p_doi,
        p_abstract,
        p_citation_count
    );

    -- Step 2: Link the publication to the faculty member
    -- This creates the many-to-many relationship in the join table
    CALL create_publication_authored_by_faculty(
        p_faculty_id,
        p_publication_id
    );

    -- Step 3: Return confirmation with both IDs for reference
    SELECT p_faculty_id AS faculty_id,
           p_publication_id AS publication_id,
           'inserted' AS action;

END $$
DELIMITER ;


-- Source: workflow/clean_faculty_generates_keyword.sql

DELIMITER $$

/**
 * Deletes old faculty keyword generation records.
 * 
 * This workflow procedure removes generation records that are older than
 * a specified datetime threshold. This is useful for maintaining the
 * database by removing records that are no longer relevant for rate limiting
 * purposes (e.g., records older than 1 hour, 1 day, etc.).
 * 
 * @param p_cutoff_datetime  Required datetime threshold
 *                           All records with generated_at older than this
 *                           datetime will be deleted
 * 
 * @returns Result set containing:
 *   - deleted_count: Number of records that were deleted
 *   - cutoff_datetime: The datetime threshold that was used
 *   - action: Status message ('cleaned')
 * 
 * @throws SQLSTATE '45000' if p_cutoff_datetime is NULL
 * 
 * Example usage:
 *   -- Delete all records older than 1 hour
 *   CALL clean_faculty_generates_keyword(DATE_SUB(NOW(), INTERVAL 1 HOUR));
 *   
 *   -- Delete all records older than 1 day
 *   CALL clean_faculty_generates_keyword(DATE_SUB(NOW(), INTERVAL 1 DAY));
 *   
 *   -- Delete all records before a specific date
 *   CALL clean_faculty_generates_keyword('2024-01-01 00:00:00');
 */
DROP PROCEDURE IF EXISTS clean_faculty_generates_keyword;
CREATE PROCEDURE clean_faculty_generates_keyword(
    IN p_cutoff_datetime DATETIME
)
BEGIN
    DECLARE v_deleted_count INT DEFAULT 0;

    -- Validate that cutoff datetime is provided
    IF p_cutoff_datetime IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'cutoff_datetime is required for clean_faculty_generates_keyword';
    END IF;

    -- Delete records older than the cutoff datetime
    DELETE FROM faculty_generates_keyword
    WHERE generated_at < p_cutoff_datetime;

    -- Get the count of deleted records
    SET v_deleted_count = ROW_COUNT();

    -- Return summary of the cleanup operation
    SELECT 
        v_deleted_count AS deleted_count,
        p_cutoff_datetime AS cutoff_datetime,
        'cleaned' AS action;
END $$

DELIMITER ;



-- Source: workflow/clean_session.sql

DELIMITER $$

/**
 * Deletes expired and old revoked sessions from the database.
 * 
 * Removes:
 *   - All sessions that have passed their expiration date
 *   - All revoked sessions older than 30 days (for audit trail retention)
 * 
 * This is a maintenance procedure that should be run periodically.
 * 
 * @returns Result set containing:
 *   - deleted_count: Number of sessions deleted
 */
DROP PROCEDURE IF EXISTS clean_session;
CREATE PROCEDURE clean_session()
BEGIN
    DELETE FROM session
    WHERE expires_at < UTC_TIMESTAMP()
       OR (revoked = TRUE AND created_at < DATE_SUB(UTC_TIMESTAMP(), INTERVAL 30 DAY));
    
    SELECT ROW_COUNT() AS deleted_count;
END $$

DELIMITER ;



-- Source: workflow/count_faculty_keyword_generations.sql

DELIMITER $$

/**
 * Counts keyword generation records for a faculty member after a specified datetime.
 * 
 * This workflow procedure is used for rate limiting by checking how many times
 * a faculty member has requested keyword generation within a specific time period.
 * Returns the count of records where generated_at is greater than or equal to
 * the provided datetime threshold.
 * 
 * @param p_faculty_id      Required UUID of the faculty member to check
 * @param p_since_datetime  Required datetime threshold
 *                          Counts all records with generated_at >= this datetime
 * 
 * @returns Result set containing:
 *   - faculty_id: UUID of the faculty member
 *   - generation_count: Number of generation records since the datetime
 *   - since_datetime: The datetime threshold that was used
 * 
 * @throws SQLSTATE '45000' if p_faculty_id or p_since_datetime is NULL
 * 
 * Example usage:
 *   -- Count generations in the last hour
 *   CALL count_faculty_keyword_generations('faculty-uuid', DATE_SUB(NOW(), INTERVAL 1 HOUR));
 *   
 *   -- Count generations in the last 24 hours
 *   CALL count_faculty_keyword_generations('faculty-uuid', DATE_SUB(NOW(), INTERVAL 24 HOUR));
 *   
 *   -- Count generations since a specific date
 *   CALL count_faculty_keyword_generations('faculty-uuid', '2024-01-01 00:00:00');
 */
CREATE PROCEDURE count_faculty_keyword_generations(
    IN p_faculty_id CHAR(36),
    IN p_since_datetime DATETIME,
    OUT p_generation_count INT
)
BEGIN
    -- Validate required parameters
    IF p_faculty_id IS NULL OR TRIM(p_faculty_id) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'faculty_id is required for count_faculty_keyword_generations';
    END IF;

    IF p_since_datetime IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'since_datetime is required for count_faculty_keyword_generations';
    END IF;

    -- Count records for this faculty member generated at or after the datetime threshold
    SELECT COUNT(*) INTO p_generation_count
    FROM faculty_generates_keyword
    WHERE faculty_id = p_faculty_id
      AND generated_at >= p_since_datetime;
END $$

DELIMITER ;



-- Source: workflow/recommend_faculty_by_department.sql

DELIMITER $$

/**
 * Generates faculty recommendations based on shared departments.
 * 
 * This workflow procedure creates recommendation relationships between faculty
 * members who work in the same department. This helps connect faculty who are
 * colleagues in the same academic department, regardless of which institution
 * they work at.
 * 
 * The procedure inserts records into faculty_recommended_to_faculty for pairs
 * where both faculty members belong to the same department:
 * - source_faculty_id: One faculty member in department x
 * - target_faculty_id: Another faculty member also in department x
 * 
 * Recommendations are directional (source -> target). This connects faculty
 * across different institutions if they share the same department name.
 * 
 * @returns No result set. Use read procedures to view the generated recommendations.
 * 
 * Note: The primary key constraint on faculty_recommended_to_faculty prevents
 * duplicate recommendations. Running this multiple times will update existing
 * records rather than creating duplicates.
 */
DROP PROCEDURE IF EXISTS recommend_faculty_by_department;
CREATE PROCEDURE recommend_faculty_by_department()
BEGIN
    -- INSERT directional recommendations
    -- For each pair of faculty members who belong to the same department,
    -- create a recommendation from one to the other
    -- Note: This connects faculty across different institutions if they share
    -- the same department name
    INSERT INTO faculty_recommended_to_faculty (
        source_faculty_id,
        target_faculty_id,
        match_score,
        created_at
    )
    SELECT DISTINCT
        fd1.faculty_id      AS source_faculty_id,
        fd2.faculty_id      AS target_faculty_id,
        NULL                AS match_score,
        CURDATE()           AS created_at
    FROM faculty_department AS fd1
    JOIN faculty_department AS fd2
        ON fd1.department_name = fd2.department_name
    WHERE fd1.faculty_id <> fd2.faculty_id
    ON DUPLICATE KEY UPDATE
        match_score = VALUES(match_score),
        created_at = VALUES(created_at);

END $$

DELIMITER ;


-- Source: workflow/recommend_faculty_by_grant_keyword.sql

DELIMITER $$

/**
 * Generates faculty recommendations based on grant keywords.
 * 
 * This workflow procedure creates recommendation relationships between faculty
 * members where one faculty member has received a grant associated with a
 * keyword, and another faculty member researches that same keyword. This helps
 * connect faculty who work in similar research areas through their funding.
 * 
 * The procedure inserts records into faculty_recommended_to_faculty for pairs
 * where:
 * - source_faculty_id: Faculty member who received a grant with keyword x
 * - target_faculty_id: Faculty member who researches keyword x
 * 
 * Recommendations are directional (source -> target).
 * 
 * @returns No result set. Use read procedures to view the generated recommendations.
 * 
 * Note: The primary key constraint on faculty_recommended_to_faculty prevents
 * duplicate recommendations. Running this multiple times will update existing
 * records rather than creating duplicates.
 */
DROP PROCEDURE IF EXISTS recommend_faculty_by_grant_keyword;
CREATE PROCEDURE recommend_faculty_by_grant_keyword()
BEGIN
    -- INSERT directional recommendations
    -- For each faculty member who has received a grant with keyword x,
    -- recommend them to all faculty members who research keyword x
    INSERT INTO faculty_recommended_to_faculty (
        source_faculty_id,
        target_faculty_id,
        match_score,
        created_at
    )
    SELECT DISTINCT
        ggf.faculty_id      AS source_faculty_id,
        frk.faculty_id      AS target_faculty_id,
        NULL                AS match_score,
        CURDATE()           AS created_at
    FROM grants_granted_to_faculty AS ggf
    JOIN grants_for_keyword AS gfk
        ON ggf.grant_id = gfk.grant_id
    JOIN faculty_researches_keyword AS frk
        ON gfk.name = frk.name
    WHERE ggf.faculty_id <> frk.faculty_id
    ON DUPLICATE KEY UPDATE
        match_score = VALUES(match_score),
        created_at = VALUES(created_at);

END $$

DELIMITER ;


-- Source: workflow/recommend_faculty_by_grants.sql

DELIMITER $$

/**
 * Generates faculty recommendations based on shared grants.
 * 
 * This workflow procedure creates recommendation relationships between faculty
 * members who have received the same grants. For each pair of faculty members
 * who share at least one grant, a recommendation is created from one faculty
 * member to the other. This helps identify faculty with similar funding
 * interests and research areas.
 * 
 * The procedure inserts records into faculty_recommended_to_faculty for all
 * pairs of faculty members who have grants in common. Recommendations are
 * directional (source_faculty_id -> target_faculty_id).
 * 
 * @returns No result set. Use read procedures to view the generated recommendations.
 * 
 * Note: This procedure may create duplicate recommendations if run multiple times.
 * Consider clearing existing recommendations before running, or use a unique
 * constraint to prevent duplicates.
 */
DROP PROCEDURE IF EXISTS recommend_faculty_by_grants;
CREATE PROCEDURE recommend_faculty_by_grants()
BEGIN
    -- INSERT directional recommendations
    -- For each pair of faculty members who share a grant, create a recommendation
    INSERT INTO faculty_recommended_to_faculty (
        source_faculty_id,
        target_faculty_id,
        match_score,
        created_at
    )
    SELECT DISTINCT
        g1.faculty_id      AS source_faculty_id,
        g2.faculty_id      AS target_faculty_id,
        NULL               AS match_score,
        CURDATE()          AS created_at
    FROM grants_granted_to_faculty AS g1
    JOIN grants_granted_to_faculty AS g2
         ON g1.grant_id = g2.grant_id
    WHERE g1.faculty_id <> g2.faculty_id
    ON DUPLICATE KEY UPDATE
        match_score = VALUES(match_score),
        created_at = VALUES(created_at);
END $$

DELIMITER ;


-- Source: workflow/recommend_faculty_by_institution.sql

DELIMITER $$

/**
 * Generates faculty recommendations based on shared institutions.
 * 
 * This workflow procedure creates recommendation relationships between faculty
 * members who work or have worked at the same institution. This helps connect
 * faculty who are or were colleagues at the same institution.
 * 
 * The procedure inserts records into faculty_recommended_to_faculty for pairs
 * where both faculty members have a relationship with the same institution
 * (regardless of whether they currently work there or worked there in the past):
 * - source_faculty_id: One faculty member who works/worked at institution x
 * - target_faculty_id: Another faculty member who also works/worked at institution x
 * 
 * Recommendations are directional (source -> target).
 * 
 * @returns No result set. Use read procedures to view the generated recommendations.
 * 
 * Note: The primary key constraint on faculty_recommended_to_faculty prevents
 * duplicate recommendations. Running this multiple times will update existing
 * records rather than creating duplicates.
 */
DROP PROCEDURE IF EXISTS recommend_faculty_by_institution;
CREATE PROCEDURE recommend_faculty_by_institution()
BEGIN
    -- INSERT directional recommendations
    -- For each pair of faculty members who work or have worked at the same institution,
    -- create a recommendation from one to the other
    INSERT INTO faculty_recommended_to_faculty (
        source_faculty_id,
        target_faculty_id,
        match_score,
        created_at
    )
    SELECT DISTINCT
        fwi1.faculty_id     AS source_faculty_id,
        fwi2.faculty_id     AS target_faculty_id,
        NULL                AS match_score,
        CURDATE()           AS created_at
    FROM faculty_works_at_institution AS fwi1
    JOIN faculty_works_at_institution AS fwi2
        ON fwi1.institution_id = fwi2.institution_id
    WHERE fwi1.faculty_id <> fwi2.faculty_id
    ON DUPLICATE KEY UPDATE
        match_score = VALUES(match_score),
        created_at = VALUES(created_at);

END $$

DELIMITER ;


DELIMITER ;


-- Source: workflow/recommend_faculty_by_publication_keyword.sql

DELIMITER $$

/**
 * Generates faculty recommendations based on publication keywords.
 * 
 * This workflow procedure creates recommendation relationships between faculty
 * members where one faculty member has authored a publication that explores a
 * keyword, and another faculty member researches that same keyword. This helps
 * connect faculty who work in similar research areas through their publications.
 * 
 * The procedure inserts records into faculty_recommended_to_faculty for pairs
 * where:
 * - source_faculty_id: Faculty member who authored a publication with keyword x
 * - target_faculty_id: Faculty member who researches keyword x
 * 
 * Recommendations are directional (source -> target).
 * 
 * @returns No result set. Use read procedures to view the generated recommendations.
 * 
 * Note: The primary key constraint on faculty_recommended_to_faculty prevents
 * duplicate recommendations. Running this multiple times will update existing
 * records rather than creating duplicates.
 */
DROP PROCEDURE IF EXISTS recommend_faculty_by_publication_keyword;
CREATE PROCEDURE recommend_faculty_by_publication_keyword()
BEGIN
    -- INSERT directional recommendations
    -- For each faculty member who has authored a publication with keyword x,
    -- recommend them to all faculty members who research keyword x
    INSERT INTO faculty_recommended_to_faculty (
        source_faculty_id,
        target_faculty_id,
        match_score,
        created_at
    )
    SELECT DISTINCT
        paf.faculty_id      AS source_faculty_id,
        frk.faculty_id      AS target_faculty_id,
        NULL                AS match_score,
        CURDATE()           AS created_at
    FROM publication_authored_by_faculty AS paf
    JOIN publication_explores_keyword AS pek
        ON paf.publication_id = pek.publication_id
    JOIN faculty_researches_keyword AS frk
        ON pek.name = frk.name
    WHERE paf.faculty_id <> frk.faculty_id
    ON DUPLICATE KEY UPDATE
        match_score = VALUES(match_score),
        created_at = VALUES(created_at);

END $$

DELIMITER ;


DELIMITER ;


-- Source: workflow/recommend_faculty_by_shared_keyword.sql

DELIMITER $$

/**
 * Generates faculty recommendations based on shared research keywords.
 * 
 * This workflow procedure creates recommendation relationships between faculty
 * members who both research the same keyword. This helps connect faculty with
 * overlapping research interests.
 * 
 * The procedure inserts records into faculty_recommended_to_faculty for pairs
 * where both faculty members research the same keyword:
 * - source_faculty_id: One faculty member who researches keyword x
 * - target_faculty_id: Another faculty member who also researches keyword x
 * 
 * Recommendations are directional (source -> target), so each pair will have
 * two recommendations (A->B and B->A) if both directions are desired.
 * 
 * @returns No result set. Use read procedures to view the generated recommendations.
 * 
 * Note: The primary key constraint on faculty_recommended_to_faculty prevents
 * duplicate recommendations. Running this multiple times will update existing
 * records rather than creating duplicates.
 */
DROP PROCEDURE IF EXISTS recommend_faculty_by_shared_keyword;
CREATE PROCEDURE recommend_faculty_by_shared_keyword()
BEGIN
    -- INSERT directional recommendations
    -- For each pair of faculty members who both research the same keyword,
    -- create a recommendation from one to the other
    INSERT INTO faculty_recommended_to_faculty (
        source_faculty_id,
        target_faculty_id,
        match_score,
        created_at
    )
    SELECT DISTINCT
        frk1.faculty_id     AS source_faculty_id,
        frk2.faculty_id     AS target_faculty_id,
        NULL                AS match_score,
        CURDATE()           AS created_at
    FROM faculty_researches_keyword AS frk1
    JOIN faculty_researches_keyword AS frk2
        ON frk1.name = frk2.name
    WHERE frk1.faculty_id <> frk2.faculty_id
    ON DUPLICATE KEY UPDATE
        match_score = VALUES(match_score),
        created_at = VALUES(created_at);

END $$

DELIMITER ;


DELIMITER ;


-- Source: workflow/search_faculty.sql

DELIMITER $$

/**
 * Searches for faculty members based on optional search criteria.
 * 
 * This procedure performs a flexible search across faculty records, matching
 * against first name, last name, department, and institution. All parameters
 * are optional - if NULL, that criterion is ignored. Uses LIKE pattern matching
 * with wildcards for partial matches.
 * 
 * @param p_first_name    Optional first name to search for (partial match)
 * @param p_last_name     Optional last name to search for (partial match)
 * @param p_department    Optional department name to search for (partial match)
 * @param p_institution   Optional institution name to search for (partial match)
 * 
 * @returns Result set containing:
 *   - faculty_id: Unique identifier for the faculty member
 *   - first_name: Faculty member's first name
 *   - last_name: Faculty member's last name
 *   - department_name: Department name (if associated)
 *   - institution_name: Institution name (if associated)
 */
CREATE PROCEDURE search_faculty(
    IN p_first_name    VARCHAR(128),
    IN p_last_name     VARCHAR(128),
    IN p_department    VARCHAR(128),
    IN p_institution   VARCHAR(255)
)
BEGIN
    -- Use DISTINCT to handle cases where a faculty member has multiple departments or institutions
    SELECT DISTINCT
        f.faculty_id,
        f.first_name,
        f.last_name,
        d.department_name,
        i.name AS institution_name
    FROM faculty AS f
    -- LEFT JOIN ensures we get faculty even if they have no department
    LEFT JOIN faculty_department AS d
        ON f.faculty_id = d.faculty_id
    -- LEFT JOIN to get institution information through the works_at relationship
    LEFT JOIN faculty_works_at_institution AS w
        ON f.faculty_id = w.faculty_id
    LEFT JOIN institution AS i
        ON w.institution_id = i.institution_id
    WHERE
        -- Each condition checks if the parameter is NULL (ignore) or matches with LIKE
        -- CONCAT(value, '%') creates a pattern for partial matching (starts with)
        (p_first_name  IS NULL OR f.first_name      LIKE CONCAT(p_first_name, '%'))
        AND (p_last_name IS NULL OR f.last_name      LIKE CONCAT(p_last_name, '%'))
        AND (p_department IS NULL OR d.department_name LIKE CONCAT(p_department, '%'))
        AND (p_institution IS NULL OR i.name            LIKE CONCAT(p_institution, '%'));
END $$
DELIMITER ;


-- Source: workflow/validate_login.sql

DELIMITER $$

/**
 * Validates user login credentials and updates last login timestamp.
 * 
 * This workflow procedure authenticates a user by verifying their username
 * and password. If authentication is successful, it updates the last_login
 * timestamp and returns the faculty_id. The password is verified using
 * the stored salt and hash.
 * 
 * @param p_username    Required username to authenticate
 * @param p_password    Required password (plain text, will be hashed for comparison)
 * @param p_faculty_id  OUT parameter that receives the faculty_id if login succeeds
 *                      Returns NULL if login fails
 * @param p_status_code OUT parameter indicating the login result:
 *                      - 0: Login successful
 *                      - 1: Invalid password
 *                      - 2: Username not found
 *                      - -1: Default/error state
 * 
 * @returns No result set. Check the OUT parameters for login status.
 * 
 * @throws SQLSTATE '45000' if username or password is NULL
 */
DROP PROCEDURE IF EXISTS validate_login;
CREATE PROCEDURE validate_login(
    IN  p_username      VARCHAR(255),
    IN  p_password      VARCHAR(255),
    OUT p_faculty_id    CHAR(36),
    OUT p_status_code   TINYINT
)
BEGIN
    DECLARE v_salt          VARCHAR(255);
    DECLARE v_expected_hash VARCHAR(255);
    DECLARE v_computed_hash CHAR(64);

    IF p_username IS NULL OR p_password IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'username and password are required for validate_login';
    END IF;

    -- DEFAULT OUTPUT
    SET p_status_code = -1;
    SET p_faculty_id = NULL;

    -- CHECK USERNAME EXISTS
    IF EXISTS (SELECT 1 FROM credentials WHERE username = p_username) THEN

        -- GET EXISTING ID, SALT, & HASH
        SELECT  faculty_id, password_salt, password_hash
        INTO    p_faculty_id, v_salt, v_expected_hash
        FROM    credentials
        WHERE   username = p_username
        LIMIT   1;

        -- COMPUTE INPUT HASH 
        SET v_computed_hash = hash_password(p_password, v_salt);

        -- VALIDATE
        IF v_computed_hash = v_expected_hash THEN

            -- STATUS CODE 0 ON SUCCESS
            SET p_status_code = 0;

            UPDATE credentials
            SET last_login = NOW()
            WHERE faculty_id = p_faculty_id;

        ELSE
            -- STATUS CODE 1 ON INVALID PASSWORD
            SET p_status_code = 1;
            SET p_faculty_id = NULL;
        END IF;

    ELSE
        -- STATUS CODE 2 ON INVALID USERNAME
        SET p_status_code   = 2;
    
    END IF;
END $$

DELIMITER ;


